1. Executive Summary Single Source of Truth: packages/core-model definiert Schema + Semantik + Actions + Reducer (ohne Platzhalter) und alle anderen Layer dürfen nur darauf aufbauen.  No-Blocker-Prinzip: Erst stabile Contracts + Validierung, dann Adapter (IPC, Exporter). Dadurch sind UI/Build-Schritte austauschbar, ohne Domain zu zerreißen.  Lean MVP: Skip „fancy onboarding / advanced parser/voice / cancel support“ bis der vertikale Pfad funktioniert.  Kritische Entscheidung sofort: ID-Policy (Option A empfohlen: IDs immutable) – das reduziert Ref-Updates & Bug-Fläche massiv.  Gesamtbewertung (auf Basis eurer Checklisten, Code nicht gesehen): Verbesserungsbedürftig (weil „…/placeholders/any“ explizit als Problem markiert sind).  2. Findings ID Kategorie Stelle Beschreibung Schweregrad Risiko F1 Cohesion core-model Domain ist (vermutlich) noch nicht vollständig „real“ (Schema/Reducer/Actions ohne Platzhalter gefordert) → sonst blockiert alles downstream. High High F2 Coupling Renderer ↔ Main ↔ FS Renderer muss als „untrusted UI“ behandelt werden; Main validiert & sandboxed FS. Wenn das nicht strikt ist, entstehen Sicherheits- und Debug-Blocker. Critical High F3 Testability core-model Ohne harte Tests für Reducer/Undo/Redo/Load ist jedes UI-Refactor riskant. High Medium F4 Complexity IDs/Renames Wenn IDs editierbar sind, müsst ihr überall Referenzen nachziehen (recipes + future refs) → hoher „Shotgun Surgery“-Effekt. High High F5 Performance/Determinism exporter Export muss deterministisch sein (sort keys, keine timestamps). Sonst: flakey builds, diff-noise, schwer zu testen. Medium Medium Unsicherheit: nicht verifiziert, weil ich euren aktuellen Code nicht sehe – ich stütze mich auf eure Arbeits-/Contract-Dokumente.  3. Refactoring-Plan (klein, reversibel, committable) Repo-Hygiene & Dev-Loop (Phase 0)  Aktion: Node+pnpm pinnen, pnpm -r build/test/lint als verlässlichen Baseline-Loop herstellen.  Ziel: Keine Tooling-Blocker, reproduzierbare Builds/Tests.  Risiko: Low  Rückroll: Commit revert  Verifizierung: pnpm -r build && pnpm -r test  ID-Policy festnageln (Gate)  Aktion: Option A: IDs immutable; Rename = „copy new id + delete old“.  Ziel: Referenz-Update-Komplexität eliminieren.  Risiko: Medium (UX-Anpassung)  Rückroll: Policy revert + Rename-Actions nachrüsten  Verifizierung: UI zeigt ID read-only (EditorPanel)  core-model „hart machen“ (Phase 1, P0)  Aktion: schema.ts, validate.ts, actions.ts, reducer.ts finalisieren, keine ..., keine any-Escapes.  Ziel: Domain ist stabiler Kern für alle Module.  Risiko: Medium  Rückroll: Schrittweise (pro Datei) revert  Verifizierung: pnpm -C packages/core-model test  IPC Contract als „Port“ (Phase 2, P0)  Aktion: IpcResult-Envelope + ErrorCodes strikt, Main validiert ProjectFile & enforced sandbox (safeJoin), atomic write.  Ziel: Keine FS-Blocker im Renderer, klare Fehler, sicherer Workspace.  Risiko: High (security-relevant)  Rückroll: revert + temporär alten IPC pfad nutzen  Verifizierung: „select workspace → save → restart → load identical“  Exporter deterministisch (Phase 3, P0)  Aktion: exportProject ohne timestamps, sortierte keys, template-copy + manifest-complete Output.  Ziel: reproduzierbares Build-Artefakt.  Risiko: Medium  Rückroll: revert exporter commits  Verifizierung: ./gradlew build im exportierten Output  Pipeline erst ganz am Ende (Phase 4)  Aktion: Progress-Events + stabile Status-Texte; optional cancel später.  Ziel: UX ohne zusätzliche Komplexität im MVP.  Risiko: Medium  Rückroll: Pipeline UI/Service revert  4. Patch (Lean-Struktur/Ordnung – als direktes Zielbild) Annahme: ihr wollt „modular & sauber“ v. a. über klare Public APIs + Layer-Regeln erzwingen.  --- a/packages/core-model/src/index.ts +++ b/packages/core-model/src/index.ts @@ +// Public API: alles was andere Pakete importieren dürfen. +// Regel: Keine Imports aus "src/*" von außen, nur aus "core-model". + +export * from "./schema"; +export * from "./validate"; +export * from "./actions"; +export * from "./reducer"; + --- /dev/null +++ b/docs/contracts/README.md @@ +# Contracts (Source of Truth) +Diese Dateien sind die verbindliche Grundlage für Implementierung & Tests. +- project-json-spec-v1.md +- ipc-bridge-spec-v1.md +- exporter-manifest-v1.md + +Regel: Implementierung muss den Contracts entsprechen, nicht umgekehrt. Warum das „lean“ hilft:  Du hast eine Import-Route (core-model), weniger Kopplung & weniger „wildes“ Quer-Importieren.  Contracts liegen dort, wo sie laut DoD sein sollen.  5. Verifikation Repo-Basis: pnpm -r build && pnpm -r test  Domain: pnpm -C packages/core-model test  Persistence (manuell): workspace wählen → save → app neu starten → load → Projekt identisch  Exporter: export ausführen → im Output ./gradlew build  Security (manuell): path traversal versuchen (../) → muss E_PATH_TRAVERSAL liefern  6. Risiken/Alternativen/Rollback Risiko: ID-Immutable kann UX „streng“ wirken. Mitigation: Rename als Copy+Delete, UI klar kommunizieren.  Risiko: Strikte Validation kann alte Projekte „brechen“. Mitigation: Loader darf reparieren+warnen, Exporter verlangt fixierte Form (wie im Contract beschrieben).  Security-Risiko: IPC/FS ohne Sandbox ist kritisch. Alternative: alle FS-Operationen zentral über workspace.ts safeJoin erzwingen (ein Gate).  Rollback: Jeder Schritt = 1 Commit. Rückweg: git revert <commit> (oder Branch wegwerfen).