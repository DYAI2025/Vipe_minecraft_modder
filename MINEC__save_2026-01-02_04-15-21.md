Unten ist das "Alles"-Paket als Systemvertraege (Contracts) fuer:  Project JSON Spec (v1)  IPC/Bridge Spec (Renderer <-> Main)  Exporter Output Manifest (Fabric Mod Projektstruktur)  Build/Test Pipeline Spec  Wiring Plan + Tests (Definition of Done)  Alles ist so geschrieben, dass ihr es 1:1 als Referenz ins Repo legen koennt.  1) Project JSON Spec v1 (Single Source of Truth) 1.1 Ziele Ein einziges Dateiformat fuer Save/Load, Export und Undo/Redo.  Stabil versioniert (schemaVersion), migrationsfaehig.  Kindfreundlich editierbar, aber technisch streng validierbar.  1.2 Naming/IDs (harte Regeln) EntityId (fuer blocks/items/recipes keys):  regex: ^[a-z0-9_]+$  Beispiele: ruby_block, copper_sword, shiny_gem  ModId (Fabric mod id):  regex: ^[a-z][a-z0-9_]{1,63}$  Beispiele: kid_ruby_mod, my_first_mod  NamespacedRef (fuer Referenzen in recipes/models):  regex: ^[a-z0-9_]+:[a-z0-9_/]+$ (slash erlaubt fuer subpaths)  Beispiele: minecraft:stick, kid_ruby_mod:ruby_gem  Invariants  project.meta.modId ist die Namespace-Basis fuer alle eigenen Inhalte.  Alle keys in blocks/items/recipes sind eindeutig.  Recipes duerfen nur auf existierende Items/Blocks referenzieren oder minecraft:*.  1.3 Datentypen (kanonisch) TextureSpec Wir brauchen eine Texturdefinition, die sowohl im Preview (Renderer) als auch im Export (PNG) funktioniert.  Design (kompatibel zu eurem TextureGenerator + exporter/assets.ts):  source = "preset": value ist rock|wood|gem|metal|...  source = "dataUri": value ist PNG DataURI (data:image/png;base64,...)  optional spaeter: source="file" (importierte PNG im workspace)  {   "source": "preset",   "value": "rock" } BlockSpec Minimal (MVP) und erweiterbar:  {   "id": "ruby_block",   "name": "Ruby Block",   "properties": {     "hardness": 3.0,     "luminance": 0,     "transparent": false   },   "texture": { "source": "preset", "value": "gem" } } ItemSpec MVP:  {   "id": "ruby_gem",   "name": "Ruby",   "itemType": "gem",   "properties": {     "maxStackSize": 64,     "attackDamage": 0   },   "texture": { "source": "preset", "value": "gem" } } RecipeSpec (shaped crafting) {   "id": "ruby_block_recipe",   "type": "shaped",   "pattern": ["RRR", "RRR", "RRR"],   "key": { "R": "kid_ruby_mod:ruby_gem" },   "result": { "item": "kid_ruby_mod:ruby_block", "count": 1 } } 1.4 Project File Format (voll) Projektdatei: project.json  {   "schemaVersion": 1,   "meta": {     "modId": "kid_ruby_mod",     "name": "Ruby Mod",     "version": "0.1.0",     "author": "Kid",     "description": "My first mod!",     "createdAt": "2026-01-02T10:00:00Z",     "updatedAt": "2026-01-02T10:05:00Z"   },   "blocks": {     "ruby_block": {       "id": "ruby_block",       "name": "Ruby Block",       "properties": { "hardness": 3.0, "luminance": 0, "transparent": false },       "texture": { "source": "preset", "value": "gem" }     }   },   "items": {     "ruby_gem": {       "id": "ruby_gem",       "name": "Ruby",       "itemType": "gem",       "properties": { "maxStackSize": 64, "attackDamage": 0 },       "texture": { "source": "preset", "value": "gem" }     }   },   "recipes": {     "ruby_block_recipe": {       "id": "ruby_block_recipe",       "type": "shaped",       "pattern": ["RRR", "RRR", "RRR"],       "key": { "R": "kid_ruby_mod:ruby_gem" },       "result": { "item": "kid_ruby_mod:ruby_block", "count": 1 }     }   } } 1.5 Semantische Validierung (muss in validate.ts passieren) schemaVersion muss bekannt sein.  meta.modId/name/version required.  Alle Entities: entity.id muss dem Key entsprechen (oder automatisch beim Load "fixen" und warning).  Recipes:  pattern laenge 1..3, jede zeile 1..3  Nur chars A-Z0-9 oder (space) (Designentscheidung)  Jedes non-space char muss in key existieren  Jeder key value muss minecraft:* oder ${modId}:* sein  result.item muss existieren (block oder item) oder minecraft:*  Texture:  preset -> value in erlaubter Liste  dataUri -> muss PNG data uri sein  1.6 ID Rename Policy (kritische Entscheidung) Ihr habt aktuell UI, das IDs editieren laesst. Das ist gefaehrlich, wenn IDs als Record-Keys genutzt werden.  Empfehlung (robust, kinderfreundlich):  IDs sind immutable nach Erstellung (UI zeigt ID read-only).  Wenn man "umbenennen" will, macht man eine Copy + Delete Funktion in UI.  Alternative (mehr Aufwand):  Action RENAME_BLOCK_ID / RENAME_ITEM_ID:  move record key  update recipe refs  update any cross refs  2) IPC / Bridge Spec (Renderer <-> Main) 2.1 Prinzipien Renderer darf nie direkt FS/child_process.  Main ist authority fuer:  workspace selection  save/load  help search  build pipeline (export/build/test)  Alle IPC Payloads sind JSON-serialisierbar.  2.2 Channels (kanonisch) Workspace / Project dialog:selectWorkspace  req: {}  res: { ok: true, dir: string | null } | { ok: false, error: IpcError }  project:save  req: { workspaceDir: string, project: ProjectFile }  res: { ok: true } | { ok: false, error: IpcError }  project:load  req: { workspaceDir: string }  res: { ok: true, project: ProjectFile } | { ok: false, error: IpcError }  Help help:search  req: { query: string, limit?: number }  res: { ok: true, results: HelpResult[] } | { ok: false, error: IpcError }  Pipeline pipeline:start  req: { project: ProjectFile }  res: { ok: true, runId: string } | { ok: false, error: IpcError }  Event pipeline:progress (push)  payload: { runId: string, status: PipelineStatus }  Optional: 7) pipeline:cancel  req: { runId: string }  res: { ok: true } | { ok: false, error: IpcError }  (Optional) AI (aktuell stub) ai:queryDocs, ai:suggest bleiben optional und muessen klar getrennt werden (privacy).  2.3 Types (TS-Contract, zum Copy/Paste) export type IpcOk<T> = { ok: true } & T; export type IpcFail = { ok: false; error: IpcError }; export type IpcResult<T> = IpcOk<T> | IpcFail;  export type IpcErrorCode =   | "E_BAD_REQUEST"   | "E_WORKSPACE_REQUIRED"   | "E_PATH_TRAVERSAL"   | "E_NOT_FOUND"   | "E_VALIDATION"   | "E_IO"   | "E_PIPELINE_RUNNING"   | "E_BUILD_FAILED"   | "E_TEST_FAILED"   | "E_UNKNOWN";  export type IpcError = {   code: IpcErrorCode;   message: string;        // user-friendly   details?: string;       // logs, stack, etc (optional) };  export type PipelineStep = "export" | "build" | "test" | "done" | "error";  export type PipelineStatus = {   step: PipelineStep;   message: string;   progress?: number; // 0..1 optional   details?: string; };  export type HelpResult = {   title: string;   tags: string[];   excerpt: string;   fullContent: string; };  export type TextureSpec =   | { source: "preset"; value: string }   | { source: "dataUri"; value: string };  export type BlockSpec = {   id: string;   name: string;   properties: { hardness: number; luminance: number; transparent: boolean };   texture: TextureSpec; };  export type ItemSpec = {   id: string;   name: string;   itemType: "gem" | "sword" | "tool" | "food";   properties: { maxStackSize: number; attackDamage: number };   texture: TextureSpec; };  export type RecipeSpec = {   id: string;   type: "shaped";   pattern: string[];   key: Record<string, string>;   result: { item: string; count: number }; };  export type ProjectFile = {   schemaVersion: 1;   meta: {     modId: string;     name: string;     version: string;     author?: string;     description?: string;     createdAt?: string;     updatedAt?: string;   };   blocks: Record<string, BlockSpec>;   items: Record<string, ItemSpec>;   recipes: Record<string, RecipeSpec>; }; 2.4 Security rules (Main muss enforce) workspace.ts immer nutzen:  Save path: safeJoin(workspaceDir, "project.json")  Load path: safeJoin(workspaceDir, "project.json")  Niemals arbitrary paths aus Renderer akzeptieren (kein "write to X").  Pipeline export/build/test schreibt nur in tmp dir oder in workspace unter kontrolliertem subdir.  3) Exporter Output Manifest (Fabric Mod Projekt) Ziel: Exporter erzeugt ein vollstaendiges Gradle/Fabric Loom Projekt, buildbar via gradlew build.  3.1 Verzeichnislayout (outputDir) outputDir/   gradlew   gradlew.bat   gradle/wrapper/...   build.gradle   settings.gradle   gradle.properties    src/main/java/<packagePath>/     <ModMainClass>.java     ModRegistry.java    src/main/resources/     fabric.mod.json     <modId>.mixins.json        (optional, wenn mixins genutzt)     assets/<modId>/       lang/en_us.json       blockstates/<blockId>.json       models/block/<blockId>.json       models/item/<itemOrBlockId>.json       textures/block/<blockId>.png       textures/item/<itemId>.png 3.2 Placeholder replacements (Template -> Instanz) Template enthaelt Platzhalter wie {{MOD_ID}}, TemplateMod, com.example.  Exporter muss ersetzen:  {{MOD_ID}} -> project.meta.modId  {{MOD_NAME}} -> project.meta.name  {{MOD_VERSION}} -> project.meta.version  {{MOD_DESC}} -> project.meta.description || ""  Java package:  com.example -> com.kidmodstudio.<modId> (oder com.<modId>; Hauptsache deterministic)  Main class:  TemplateMod -> PascalCase aus modId, z.B. KidRubyMod  3.3 Generated resource content (kanonisch) 3.3.1 Lang assets/<modId>/lang/en_us.json  Keys:  block.<modId>.<blockId> -> block name  item.<modId>.<itemId> -> item name  3.3.2 Blockstate + Models Block:  blockstates/<blockId>.json: single variant -> model "<modId>:block/<blockId>"  models/block/<blockId>.json: parent block/cube_all, texture "<modId>:block/<blockId>"  models/item/<blockId>.json: parent "<modId>:block/<blockId>"  Item:  models/item/<itemId>.json: parent item/generated, layer0 "<modId>:item/<itemId>"  3.3.3 Textures Wenn texture.source="preset":  Exporter generiert PNG aus preset (Option A: im exporter selbst; Option B: Renderer speichert dataUri beim preset schon).  Wenn texture.source="dataUri":  assets.ts:dataUriToBuffer -> PNG bytes -> file.  Empfehlung (einfach, konsistent):  Renderer speichert immer dataUri (egal ob preset oder nicht).  Dann export ist trivial: immer dataUriToBuffer.  3.4 Java Registry (minimal) ModRegistry.java registriert:  Blocks: Registry.register(Registries.BLOCK, new Identifier(modId, id), new Block(...))  BlockItems: fuer jeden Block ein BlockItem im ITEM registry  Items: normale Items  Property mapping (MVP):  hardness -> AbstractBlock.Settings.create().strength(hardness)  luminance -> .luminance(s -> luminance)  transparent -> .nonOpaque() (wenn true)  4) Build/Test Pipeline Spec 4.1 Pipeline Steps (status contract) export:  scaffold + generate all files  build:  gradlew build (oder ./gradlew build)  test:  gradlew runServer (headless), timeout, logs parse  done/error  4.2 Result semantics done: build ok, test ok (oder test optional, je nach button)  error:  message: kinderfreundlich ("Oh no! The mod did not build.")  details: logs/snippets (developer mode)  4.3 Cancel (optional, aber sinnvoll) Main merkt sich child_process handles und killt process tree bei cancel.  5) Wiring Plan + Tests (Definition of Done) 5.1 Reihenfolge (minimiert Chaos) Phase 1: core-model truth Schema vollstaendig  validateProject robust + semantik  reducer undo/redo korrekt  Parser tests gruen (oder Parser als "beta")  DoD Phase 1  pnpm -r test gruen fuer core-model  Phase 2: Save/Load end-to-end IPC implementiert project:save/load + workspace sandbox  Renderer nutzt real bridge, mock nur im browser  DoD Phase 2  Save -> close -> load -> identisches project  invalid project -> validation error sauber angezeigt  Phase 3: Exporter deterministic output Exporter erzeugt manifest layout  Resources + Java compile  DoD Phase 3  Export -> gradlew build erzeugt jar  jar enthaelt assets + registries  Phase 4: Testbot reliability runServer timeout und analyzer reasons  BuildService progress events stabil  DoD Phase 4  Pipeline zeigt alle Steps, bricht sauber ab bei Fehlern, liefert reason  5.2 Minimal Testmatrix (schnell, aber tragfaehig) Unit core-model:  schema valid/invalid  validateProject: missing refs in recipe -> error  reducer: create/update/delete + undo/redo  exporter:  export writes expected files (snapshot paths)  dataUriToBuffer handles invalid -> fallback  testbot:  analyzer detects success  analyzer detects common crash strings  Integration (smoke) BuildService:  start pipeline with tiny project -> reaches build step (in CI evtl. skip real gradle)  E2E local:  export + gradlew build  runServer -> analyzer success  Abschluss: Was du jetzt "in Stein meisseln" kannst Wenn ihr "alles" wirklich sauber zusammensetzen wollt, legt diese 3 Dateien als Contracts ins Repo:  docs/contracts/project-json-spec-v1.md (Abschnitt 1)  docs/contracts/ipc-bridge-spec-v1.md (Abschnitt 2)  docs/contracts/exporter-manifest-v1.md (Abschnitt 3 + 4)  Wenn du willst, kann ich dir diese drei Markdown-Dateien im exakt passenden Repo-Style auch direkt als fertigen Textblock strukturieren (inkl. Checklists), sodass du sie nur kopieren musst.  Du: perfekt ja 3.PHASE-D.R.A._Deep-Reasoning-Analyst sagte:  Nachgedacht f√ºr 6s Super. Hier sind die 3 fertigen Contract-Dateien als Copy/Paste (ASCII-only). Lege sie am besten unter docs/contracts/ ab:  docs/contracts/project-json-spec-v1.md  docs/contracts/ipc-bridge-spec-v1.md  docs/contracts/exporter-manifest-v1.md  # Project JSON Spec v1 (Single Source of Truth)  Status: Draft v1 Owner: Mod Studio Core Last updated: 2026-01-02  ## 0. Goals  This document defines the canonical project file format used by: - Save/Load (workspace persistence) - Undo/Redo (domain state) - Export (Fabric mod generation) - Test pipeline (build + runServer smoke test)  Requirements: - Deterministic, versioned, migration-friendly - Strictly validatable (schema + semantics) - UI-friendly (safe defaults, clear constraints) - JSON-serializable only (no functions, no binary)  ## 1. File location  Workspace directory selected by user. Project file: `project.json`  ## 2. Versioning  Top-level field: - `schemaVersion: 1`  Rule: - Unknown schemaVersion MUST be rejected (or migrated explicitly).  ## 3. Naming and IDs  ### 3.1 EntityId (keys in blocks/items/recipes) Regex: - `^[a-z0-9_]+$`  Examples: - `ruby_block` - `copper_sword` - `shiny_gem`  ### 3.2 ModId (Fabric mod id) Regex: - `^[a-z][a-z0-9_]{1,63}$`  Examples: - `kid_ruby_mod` - `my_first_mod`  ### 3.3 NamespacedRef (references in recipes/results) Regex (recommended): - `^[a-z0-9_]+:[a-z0-9_/]+$`  Examples: - `minecraft:stick` - `kid_ruby_mod:ruby_gem` - `kid_ruby_mod:block/ruby_block` (allowed but prefer `<modId>:<entityId>` for entity refs)  ## 4. Canonical types  ### 4.1 TextureSpec  TextureSpec MUST be one of:  A) Preset texture: - `source = "preset"` - `value` is a known preset string (see 4.1.3)  B) Embedded PNG data URI: - `source = "dataUri"` - `value` is `data:image/png;base64,...`  Recommended strategy: - Persist ALWAYS as `dataUri` (even for presets) to make export trivial and deterministic.  #### 4.1.1 TextureSpec (preset) example ```json { "source": "preset", "value": "gem" } 4.1.2 TextureSpec (dataUri) example { "source": "dataUri", "value": "data:image/png;base64,iVBORw0K..." } 4.1.3 Allowed preset values (v1) rock  wood  gem  metal  grass  sand  (Expandable. Unknown presets MUST be rejected or mapped to a safe fallback.)  4.2 BlockSpec Fields:  id: EntityId  name: string (1..64 recommended)  properties:  hardness: number (0..50 recommended)  luminance: number (0..15)  transparent: boolean  texture: TextureSpec  Example:  {   "id": "ruby_block",   "name": "Ruby Block",   "properties": { "hardness": 3.0, "luminance": 0, "transparent": false },   "texture": { "source": "preset", "value": "gem" } } 4.3 ItemSpec Fields:  id: EntityId  name: string (1..64 recommended)  itemType: "gem" | "sword" | "tool" | "food" (v1)  properties:  maxStackSize: number (1..64)  attackDamage: number (0..50)  texture: TextureSpec  Example:  {   "id": "ruby_gem",   "name": "Ruby",   "itemType": "gem",   "properties": { "maxStackSize": 64, "attackDamage": 0 },   "texture": { "source": "preset", "value": "gem" } } 4.4 RecipeSpec (shaped only in v1) Fields:  id: EntityId  type: "shaped"  pattern: string[] (1..3 rows; each row 1..3 chars)  key: Record<string, NamespacedRef> (single-char keys)  result: { item: NamespacedRef, count: number }  Rules:  Pattern chars: A-Z0-9 or space (recommended). Any other char -> invalid.  Every non-space char must exist in key.  Every entry in key must be a valid NamespacedRef.  result.item must be valid NamespacedRef.  count: 1..64  Example:  {   "id": "ruby_block_recipe",   "type": "shaped",   "pattern": ["RRR", "RRR", "RRR"],   "key": { "R": "kid_ruby_mod:ruby_gem" },   "result": { "item": "kid_ruby_mod:ruby_block", "count": 1 } } 5. ProjectFile (complete) Top-level fields:  schemaVersion: 1  meta  blocks  items  recipes  5.1 meta Fields:  modId: ModId (required)  name: string (required)  version: string (required, SemVer recommended)  author?: string  description?: string  createdAt?: string (ISO-8601)  updatedAt?: string (ISO-8601)  5.2 blocks/items/recipes containers Each is a dictionary keyed by EntityId:  blocks: Record<EntityId, BlockSpec>  items: Record<EntityId, ItemSpec>  recipes: Record<EntityId, RecipeSpec>  Invariant:  For each container entry:  Key MUST equal value.id (or loader fixes and emits warning, but exporter MUST see fixed form).  5.3 Full example {   "schemaVersion": 1,   "meta": {     "modId": "kid_ruby_mod",     "name": "Ruby Mod",     "version": "0.1.0",     "author": "Kid",     "description": "My first mod!",     "createdAt": "2026-01-02T10:00:00Z",     "updatedAt": "2026-01-02T10:05:00Z"   },   "blocks": {     "ruby_block": {       "id": "ruby_block",       "name": "Ruby Block",       "properties": { "hardness": 3.0, "luminance": 0, "transparent": false },       "texture": { "source": "preset", "value": "gem" }     }   },   "items": {     "ruby_gem": {       "id": "ruby_gem",       "name": "Ruby",       "itemType": "gem",       "properties": { "maxStackSize": 64, "attackDamage": 0 },       "texture": { "source": "preset", "value": "gem" }     }   },   "recipes": {     "ruby_block_recipe": {       "id": "ruby_block_recipe",       "type": "shaped",       "pattern": ["RRR", "RRR", "RRR"],       "key": { "R": "kid_ruby_mod:ruby_gem" },       "result": { "item": "kid_ruby_mod:ruby_block", "count": 1 }     }   } } 6. Semantic validation (must pass before export) Must validate:  schemaVersion known  meta fields required and regex-valid  container keys are valid EntityId  entity.id equals key  texture rules:  preset -> allowed list  dataUri -> must be PNG data URI  recipe references:  all key refs must exist OR be minecraft:*  result ref must exist OR be minecraft:*  if ref namespace equals project.meta.modId, the entity must exist in blocks/items  no duplicate IDs across blocks/items (recommended restriction for v1 to reduce confusion)  7. ID rename policy (choose one) Option A (recommended):  IDs are immutable after creation (UI shows read-only).  Rename is implemented as "copy as new ID" + "delete old".  Option B:  Introduce explicit actions: RENAME_BLOCK_ID, RENAME_ITEM_ID  Must update:  container keys  recipe refs in key/result  any future refs (loot tables, tags, etc.)  8. Migration If a v2 appears:  Provide migrate(project: any): ProjectFileV2 in core-model.  Exporter MUST accept only latest version, or do migration first.  9. Changelog v1: blocks, items, shaped recipes, preset/dataUri textures, meta   ---  ```markdown # IPC / Bridge Spec v1 (Renderer <-> Electron Main)  Status: Draft v1 Owner: Desktop App Last updated: 2026-01-02  ## 0. Principles  - Renderer is untrusted UI. - Main process owns FS, dialogs, child_process, temp dirs. - All payloads are JSON-serializable. - Main MUST validate all inputs (schema + semantics). - Main MUST enforce workspace sandbox (no path traversal).  ## 1. Bridge surface (window.KidMod)  Expose in preload via contextBridge: - `selectWorkspaceDir()` - `saveProject(workspaceDir, project)` - `loadProject(workspaceDir)` - `searchHelp(query, limit?)` - `startBuildPipeline(project)` -> runId - `onBuildProgress(cb)` -> unsubscribe - (optional) `cancelBuildPipeline(runId)`  ## 2. Canonical IPC message shapes  ### 2.1 Result envelope  ```ts export type IpcOk<T> = { ok: true } & T; export type IpcFail = { ok: false; error: IpcError }; export type IpcResult<T> = IpcOk<T> | IpcFail;  export type IpcErrorCode =   | "E_BAD_REQUEST"   | "E_WORKSPACE_REQUIRED"   | "E_PATH_TRAVERSAL"   | "E_NOT_FOUND"   | "E_VALIDATION"   | "E_IO"   | "E_PIPELINE_RUNNING"   | "E_BUILD_FAILED"   | "E_TEST_FAILED"   | "E_UNKNOWN";  export type IpcError = {   code: IpcErrorCode;   message: string;   // user-friendly   details?: string;  // dev details/log snippet }; 2.2 Pipeline status export type PipelineStep = "export" | "build" | "test" | "done" | "error";  export type PipelineStatus = {   step: PipelineStep;   message: string;   progress?: number; // 0..1 optional   details?: string; }; 2.3 Help result export type HelpResult = {   title: string;   tags: string[];   excerpt: string;   fullContent: string; }; 3. IPC channels 3.1 Workspace Channel: dialog:selectWorkspace  request: {}  success: { ok: true, dir: string | null }  fail: { ok: false, error: IpcError }  Notes:  dir: null means user cancelled.  Main MUST return absolute path.  3.2 Project persistence Channel: project:save  request:  { "workspaceDir": "/abs/path", "project": { ...ProjectFile... } } success: { ok: true }  fail: { ok: false, error: IpcError }  Rules:  workspaceDir required (else E_WORKSPACE_REQUIRED)  save path MUST be: safeJoin(workspaceDir, "project.json")  validateProject(project) must pass (else E_VALIDATION)  write must be atomic (recommended):  write temp file -> rename  Channel: project:load  request:  { "workspaceDir": "/abs/path" } success: { ok: true, project: ProjectFile }  fail: { ok: false, error: IpcError }  Rules:  load path MUST be: safeJoin(workspaceDir, "project.json")  if missing -> E_NOT_FOUND  validateProject(project) must pass (or migrate) else E_VALIDATION  3.3 Help Channel: help:search  request:  { "query": "blocks", "limit": 5 } success:  { "ok": true, "results": [ { "title": "...", "tags": [], "excerpt": "...", "fullContent": "..." } ] } fail: { ok: false, error: IpcError }  Rules:  query trimmed, 1..200 chars recommended  limit default 5, clamp 1..20  3.4 Build pipeline Channel: pipeline:start  request:  { "project": { ...ProjectFile... } } success:  { "ok": true, "runId": "uuid-or-timestamp" } fail: { ok: false, error: IpcError }  Rules:  validateProject must pass  if a run is already active and no concurrency: E_PIPELINE_RUNNING  Event: pipeline:progress  payload:  { "runId": "same-id", "status": { "step": "build", "message": "...", "progress": 0.4, "details": "..." } } Optional channel: pipeline:cancel  request: { "runId": "..." }  success: { ok: true }  fail: { ok: false, error: IpcError }  4. Security requirements (must) Use workspace sandbox helper for EVERY file op.  Never accept a filename/path from Renderer other than workspaceDir (which is also validated).  Reject any attempt to escape workspace (E_PATH_TRAVERSAL).  Sanitize and clamp user strings:  modId/name/version lengths  help query length  5. Observability Main should log (dev only) runId, step transitions, and errors.  Renderer should show user-friendly errors, and optionally a "Show details" dev pane.  6. Backwards compatibility If Project JSON evolves:  Main loads -> migrate -> returns latest schemaVersion to Renderer.   ---  ```markdown # Exporter Manifest v1 (Fabric Mod Output Contract)  Status: Draft v1 Owner: Exporter Last updated: 2026-01-02  ## 0. Goals  Given a validated ProjectFile (schemaVersion=1), exporter produces a deterministic Fabric Loom mod project that: - builds via `gradlew build` - contains assets for blocks/items (models, blockstates, textures, lang) - registers blocks/items in Java - can be smoke-tested via `gradlew runServer` (optional)  ## 1. Input  - `ProjectFile` as defined in `project-json-spec-v1.md` - All textures should ideally be `dataUri` by the time exporter runs.  Precondition: - `validateProject(project)` passed (schema + semantics)  ## 2. Output directory layout  Exporter writes into `outputDir` (usually a temp directory or a controlled workspace subdir):  outputDir/ gradlew gradlew.bat gradle/ wrapper/ gradle-wrapper.jar gradle-wrapper.properties  build.gradle settings.gradle gradle.properties  src/main/java/<packagePath>/ <ModMainClass>.java ModRegistry.java  src/main/resources/ fabric.mod.json <modId>.mixins.json (optional) assets/<modId>/ lang/en_us.json blockstates/<blockId>.json models/block/<blockId>.json models/item/<blockId>.json (block item model) models/item/<itemId>.json textures/block/<blockId>.png textures/item/<itemId>.png   Notes: - Block items use `models/item/<blockId>.json` referencing the block model. - Items use `models/item/<itemId>.json` with `item/generated`.  ## 3. Template instantiation rules  Template is stored in `packages/exporter/template`.  Exporter MUST: - copy template to outputDir - replace placeholders  ### 3.1 Placeholder mapping  - `{{MOD_ID}}` -> `project.meta.modId` - `{{MOD_NAME}}` -> `project.meta.name` - `{{MOD_VERSION}}` -> `project.meta.version` - `{{MOD_DESC}}` -> `project.meta.description || ""`  Java package replacement: - Template package `com.example` -> `com.kidmodstudio.<modId>` (recommended deterministic) - `<packagePath>` is `com/kidmodstudio/<modId>`  Main class naming: - `TemplateMod` -> PascalCase(modId), e.g.:   - `kid_ruby_mod` -> `KidRubyMod`  Mixin file: - template has `mixin.json` - exporter renames to `<modId>.mixins.json` - fabric.mod.json must reference the renamed mixin config if used  ## 4. Generated resources  ### 4.1 Lang file  Path: - `src/main/resources/assets/<modId>/lang/en_us.json`  Content rules: - Blocks:   - key: `block.<modId>.<blockId>`   - value: `block.name` - Items:   - key: `item.<modId>.<itemId>`   - value: `item.name`  ### 4.2 Blockstate JSON  Path: - `assets/<modId>/blockstates/<blockId>.json`  Minimal v1: ```json {   "variants": {     "": { "model": "<modId>:block/<blockId>" }   } } 4.3 Block model JSON Path:  assets/<modId>/models/block/<blockId>.json  {   "parent": "block/cube_all",   "textures": { "all": "<modId>:block/<blockId>" } } 4.4 Block item model JSON Path:  assets/<modId>/models/item/<blockId>.json  { "parent": "<modId>:block/<blockId>" } 4.5 Item model JSON Path:  assets/<modId>/models/item/<itemId>.json  {   "parent": "item/generated",   "textures": { "layer0": "<modId>:item/<itemId>" } } 5. Textures 5.1 Texture source handling Preferred:  Always store TextureSpec as dataUri in ProjectFile (UI responsibility). Then exporter does:  dataUriToBuffer(pngDataUri) -> write bytes to .png  Fallback:  If source="preset" appears, exporter maps preset -> generate PNG (either internal generator or via a fixed asset set).  5.2 Paths Block textures:  assets/<modId>/textures/block/<blockId>.png  Item textures:  assets/<modId>/textures/item/<itemId>.png  6. Java generation 6.1 Mod main class <ModMainClass>.java should:  implement ModInitializer  call ModRegistry.registerAll() (or similar)  6.2 Registry class ModRegistry.java registers:  Blocks: Registries.BLOCK  Block items: Registries.ITEM using new BlockItem(block, new Item.Settings())  Items: Registries.ITEM  Identifier rule:  new Identifier(modId, entityId)  Property mapping (v1):  hardness -> .strength(hardness)  luminance -> .luminance(s -> luminance)  transparent -> .nonOpaque() if true  7. Recipes (v1 optional) If shaped recipes are exported:  Path:  data/<modId>/recipes/<recipeId>.json  Content per vanilla shaped recipe format.  (If not implemented yet, omit recipe export in v1 and keep only block/item registration.)  8. Build contract Exporter should support:  runBuild(outputDir) -> runs gradlew build  Must collect:  exit code  stdout/stderr logs  resulting jar path (expected under build/libs/*.jar)  Error mapping:  Non-zero exit -> E_BUILD_FAILED with a short summary + logs snippet.  9. Test contract (smoke test) Testbot runs:  gradlew runServer  Timeout (e.g. 180s)  Analyzer decides:  success if typical "Done" line appears  failure if crash patterns appear or timeout  Error mapping:  Crash -> E_TEST_FAILED  Timeout -> E_TEST_FAILED with message "Server did not start in time"  10. Determinism rules For a given ProjectFile:  generated file paths are stable  file contents are stable (no timestamps inside generated files)  ordering in JSON should be stable if possible (sort keys)  11. Exporter definition of done Export creates all required directories/files  gradlew build succeeds for a minimal project (1 block, 1 item)  jar contains:  fabric.mod.json  assets/<modId>/*  compiled classes including registry