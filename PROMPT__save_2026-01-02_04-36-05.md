Unten ist ein Skill-Manifest (Contract-first), das deine genannten Einzelteile logisch verkettet: erst die gemeinsamen Verträge (Envelopes/Errors/Streaming), dann Core-Runtime, dann I/O (Voice/Avatar), dann Cognition/Memory/RAG, dann Actions/Watcher/Proactive, zuletzt UI. (Die Error-/Status-Envelopes sind bewusst an eure „stable envelope“-Denke angelehnt. )  manifestVersion: 0.1 system:   id: local-hub-jarvis   name: "Local Hub (Jarvis)"   mode: local-first   principles:     - "contract-first"     - "streaming-first"     - "privacy-by-default"     - "observable-by-default"  # ------------------------------------------------------------------- # 0) SHARED CONTRACTS (one truth for all modules) # ------------------------------------------------------------------- contracts:   eventEnvelope:     # Everything is an event (even HTTP responses can be wrapped)     fields: [type, traceId, ts, source, payload, severity]     example:       type: "voice.chunk"       traceId: "t-20260102-abc"       ts: "2026-01-02T12:00:00Z"       source: "skill.voice.stt"       severity: "info"       payload: { bytesB64: "...", seq: 12 }    resultEnvelope:     # Same idea as IPC envelopes: ok/fail with stable error codes/messages. :contentReference[oaicite:1]{index=1}     ok: { ok: true, data: {} }     fail:       ok: false       error: { code: "E_VALIDATION", message: "Fix something first.", details: "..." }     errorCodes:       - E_BAD_REQUEST       - E_PERMISSION_REQUIRED       - E_VALIDATION       - E_IO       - E_RESOURCE_LIMIT       - E_DEPENDENCY_UNAVAILABLE       - E_TIMEOUT       - E_UNKNOWN    streaming:     # Small, deterministic semantics: start/chunk/end.     messageTypes:       - stream.start       - stream.chunk       - stream.end    security:     capabilityTiers:       - read_only       - write_local_confirm       - destructive_two_step       - network_off_by_default     audit:       ledgerEnabled: true       fields: [traceId, actorSkill, action, targets, beforeHash, afterHash, ts]    observability:     tracing: true     metrics:       - ttft_ms       - voice_rtt_ms       - stt_ms       - tts_ms       - avatar_ms       - rag_ms       - tool_ms     logs:       correlatedBy: traceId  # ------------------------------------------------------------------- # 1) CORE RUNTIME (the orchestrator / kernel) # ------------------------------------------------------------------- kernel:   id: kernel.orchestrator   api:     http:       base: "http://localhost:8000"       endpoints:         - { path: "/chat", method: "POST", stream: true }         - { path: "/events", method: "POST" }     ws:       - { path: "/ws/voice", direction: "bi", stream: true }       - { path: "/ws/avatar", direction: "out", stream: true }   stateMachine:     states: [idle, listening, transcribing, thinking, speaking, rendering, acting, error]     transitions:       - { on: "voice.start", from: idle, to: listening }       - { on: "stt.final", from: listening, to: thinking }       - { on: "llm.text", from: thinking, to: speaking }       - { on: "tts.audio", from: speaking, to: rendering }       - { on: "avatar.frames", from: rendering, to: idle }       - { on: "tool.request", from: thinking, to: acting }       - { on: "error.*", from: "*", to: error }  # ------------------------------------------------------------------- # 2) SKILLS (plug-in registry) # Order = dependencies first, consumers later. # ------------------------------------------------------------------- skills:    # ---------------------------   # 2.1 LLM (Core Brain)   # ---------------------------   - id: skill.llm.ollama     version: 0.1     role: "core-brain"     transport:       type: http       base: "http://localhost:11434"     provides: ["llm.complete.stream", "llm.embed"]     consumes: ["chat.prompt", "rag.context", "memory.context"]     latencyClass: realtime_text     resources: { cpu: medium, gpu: optional, vram: "low..high(depends model)" }     config:       model: "llama3.2"  # example       temperature: 0.4    # ---------------------------   # 2.2 STT / TTS (Voice Interaction)   # ---------------------------   - id: skill.voice.stt.fasterwhisper     version: 0.1     role: "stt"     provides: ["stt.partial", "stt.final"]     consumes: ["voice.chunk"]     latencyClass: realtime_audio     resources: { cpu: medium, gpu: optional }     config:       model: "distil-whisper"  # example       language: "de"    - id: skill.voice.tts.xtts     version: 0.1     role: "tts"     provides: ["tts.audio.stream", "tts.viseme_timing"]     consumes: ["llm.text"]     latencyClass: realtime_audio     resources: { cpu: medium, gpu: preferred, vram: medium }     config:       voicePreset: "local-voice-01"    # ---------------------------   # 2.3 Visual Layer (Avatar)   # ---------------------------   - id: skill.avatar.liveavatar     version: 0.1     role: "face"     provides: ["avatar.frames.stream"]     consumes: ["tts.audio.stream", "tts.viseme_timing"]     latencyClass: realtime_video     resources: { gpu: required, vram: high }     transport:       type: ws       endpoint: "/ws/avatar"    # ---------------------------   # 2.4 Memory + RAG (Context)   # ---------------------------   - id: skill.memory.evermem.episodic     version: 0.1     role: "long-term-episodic"     provides: ["memory.context", "memory.write.receipt"]     consumes: ["turn.end", "conversation.summary"]     latencyClass: background     storage:       type: sqlite       path: "./data/memory.sqlite"     policies:       writeOn: ["turn.end"]       retention: "user-controlled"    - id: skill.rag.smartrag.semantic     version: 0.1     role: "doc-knowledge"     provides: ["rag.context"]     consumes: ["chat.query", "index.request"]     latencyClass: hybrid     storage:       type: vectordb       engine: "qdrant|chromadb"       path: "./data/vectors"     config:       topK: 6       chunking: { size: 800, overlap: 120 }    # ---------------------------   # 2.5 Agentic Layer (Actions)   # ---------------------------   - id: skill.action.opencode.fs_read     version: 0.1     role: "tools.read"     provides: ["tool.result"]     consumes: ["tool.request"]     capabilityTier: read_only     actions:       - { name: "read_file", params: ["path"] }       - { name: "list_dir", params: ["path"] }       - { name: "search_in_files", params: ["query", "path"] }    - id: skill.action.opencode.fs_write     version: 0.1     role: "tools.write"     provides: ["tool.result"]     consumes: ["tool.request"]     capabilityTier: write_local_confirm     actions:       - { name: "write_file", params: ["path", "content"], requiresConfirm: true }       - { name: "apply_patch", params: ["diff"], requiresConfirm: true }     auditLedger: true    # ---------------------------   # 2.6 Watchers + Proactive (Events -> Triage -> Nudge)   # ---------------------------   - id: skill.watcher.filesystem     version: 0.1     role: "signals.fs"     provides: ["event.fs.changed"]     consumes: []     latencyClass: background     config:       watchPaths: ["~/projects"]       debounceMs: 300    - id: skill.watcher.system     version: 0.1     role: "signals.system"     provides: ["event.system.health"]     consumes: []     latencyClass: background     config:       sampleEverySec: 5       thresholds: { cpu: 0.9, vram: 0.9, disk: 0.95 }    - id: skill.proactive.triage     version: 0.1     role: "attention-manager"     provides: ["nudge.proposal", "nudge.dispatch"]     consumes: ["event.fs.changed", "event.system.health", "pipeline.status", "calendar.event"]     latencyClass: hybrid     config:       interruptibility: ["dnd", "focus", "available"]       rateLimits:         maxVoiceNudgesPerHour: 2         maxToastsPerHour: 6     policy:       ladder:         - { level: 1, channel: "dashboard_only", when: "low" }         - { level: 2, channel: "toast", when: "medium" }         - { level: 3, channel: "voice", when: "high_and_actionable" }    # ---------------------------   # 2.7 UI (Dashboard)   # ---------------------------   - id: skill.ui.dashboard     version: 0.1     role: "command-center"     provides: ["ui.command", "ui.feedback", "ui.interruptibility"]     consumes: ["nudge.dispatch", "kernel.trace", "ledger.entries"]     transport: { type: "web", framework: "nextjs" }  # ------------------------------------------------------------------- # 3) PIPELINES (how skills are chained) # Similar in spirit to build/test pipelines: deterministic step model + progress. :contentReference[oaicite:2]{index=2} # ------------------------------------------------------------------- pipelines:    - id: pipeline.chat.text     steps:       - { emit: "chat.query" }       - { call: "skill.rag.smartrag.semantic", optional: true }       - { call: "skill.memory.evermem.episodic", mode: "read_context", optional: true }       - { call: "skill.llm.ollama" }       - { emit: "turn.end" }    - id: pipeline.voice.turn     steps:       - { recv: "voice.chunk", via: "kernel.ws:/ws/voice" }       - { call: "skill.voice.stt.fasterwhisper", stream: true }       - { call: "skill.rag.smartrag.semantic", optional: true }       - { call: "skill.llm.ollama", stream: true }       - { call: "skill.voice.tts.xtts", stream: true }       - { call: "skill.avatar.liveavatar", stream: true, optional: true }       - { emit: "turn.end" }    - id: pipeline.proactive.nudge     steps:       - { recv: "event.*" }       - { call: "skill.proactive.triage" }       - { if: "needs_user_attention", then: "emit:nudge.dispatch" }       - { else: "emit:dashboard_only" }  # ------------------------------------------------------------------- # 4) DEFINITION OF DONE (minimal acceptance) # Mirrors the idea of a wiring/assembly checklist: build a thin slice, then harden. :contentReference[oaicite:3]{index=3} # ------------------------------------------------------------------- acceptance:   mvp:     - "pipeline.chat.text works (streaming)"     - "pipeline.voice.turn works end-to-end (audio in/out)"     - "ledger logs every write_local_confirm action"     - "proactive.nudge does not exceed rate limits" Wie du das praktisch nutzt (ohne Zusatz-Gelaber) Jeder Skill ist ein Plugin mit provides/consumes → der Kernel kann daraus Routing + Abhängigkeiten ableiten.  Pipelines definieren die „goldenen“ Ketten (Text-Chat, Voice-Turn, Proactive Nudge) mit stabilen Steps/Status (wie bei eurem Pipeline-Denken).  Security + Ledger ist nicht „später“: es ist ein Contract-Feld im Manifest (damit Tools nicht heimlich eskalieren).  Wenn du willst, mache ich als nächsten Schritt aus dem YAML:  ein JSON Schema für SkillManifest,  plus eine Event-Typenliste (kanonische type Strings) passend zu deinen WebSocket-/FastAPI-Endpunkten.  Du: ja 1.PHASE-START_DYAI_IdeaGPT sagte:  Nachgedacht für 12s Hier sind (1) ein JSON Schema für dein Skill-Manifest und (2) eine kanonische Event-Typenliste inkl. Payload-Shapes (minimal, aber anschlussfähig).  1) JSON Schema: SkillManifest (Draft 2020-12) {   "$schema": "https://json-schema.org/draft/2020-12/schema",   "$id": "https://local-hub.dev/schemas/skill-manifest.schema.json",   "title": "Local Hub Skill Manifest",   "type": "object",   "required": ["manifestVersion", "system", "contracts", "kernel", "skills", "pipelines"],   "additionalProperties": false,   "patternProperties": {     "^x-": {}   },   "properties": {     "manifestVersion": { "type": "string", "minLength": 1 },     "system": { "$ref": "#/$defs/System" },     "contracts": { "$ref": "#/$defs/Contracts" },     "kernel": { "$ref": "#/$defs/Kernel" },     "skills": {       "type": "array",       "minItems": 1,       "items": { "$ref": "#/$defs/Skill" }     },     "pipelines": {       "type": "array",       "minItems": 1,       "items": { "$ref": "#/$defs/Pipeline" }     },     "acceptance": { "$ref": "#/$defs/Acceptance" }   },   "$defs": {     "System": {       "type": "object",       "required": ["id", "name", "mode"],       "additionalProperties": false,       "patternProperties": { "^x-": {} },       "properties": {         "id": { "type": "string", "minLength": 1 },         "name": { "type": "string", "minLength": 1 },         "mode": { "type": "string", "enum": ["local-first", "hybrid", "remote"] },         "principles": {           "type": "array",           "items": { "type": "string" }         }       }     },      "Contracts": {       "type": "object",       "required": ["eventEnvelope", "resultEnvelope", "streaming", "security", "observability"],       "additionalProperties": false,       "patternProperties": { "^x-": {} },       "properties": {         "eventEnvelope": { "$ref": "#/$defs/EventEnvelopeContract" },         "resultEnvelope": { "$ref": "#/$defs/ResultEnvelopeContract" },         "streaming": { "$ref": "#/$defs/StreamingContract" },         "security": { "$ref": "#/$defs/SecurityContract" },         "observability": { "$ref": "#/$defs/ObservabilityContract" }       }     },      "EventEnvelopeContract": {       "type": "object",       "required": ["fields"],       "additionalProperties": false,       "patternProperties": { "^x-": {} },       "properties": {         "fields": {           "type": "array",           "minItems": 1,           "items": { "type": "string" }         },         "example": { "type": "object" }       }     },      "ResultEnvelopeContract": {       "type": "object",       "required": ["ok", "fail", "errorCodes"],       "additionalProperties": false,       "patternProperties": { "^x-": {} },       "properties": {         "ok": { "type": "object" },         "fail": { "type": "object" },         "errorCodes": {           "type": "array",           "minItems": 1,           "items": { "type": "string", "minLength": 1 }         }       }     },      "StreamingContract": {       "type": "object",       "required": ["messageTypes"],       "additionalProperties": false,       "patternProperties": { "^x-": {} },       "properties": {         "messageTypes": {           "type": "array",           "minItems": 1,           "items": { "type": "string", "enum": ["stream.start", "stream.chunk", "stream.end"] }         }       }     },      "SecurityContract": {       "type": "object",       "required": ["capabilityTiers", "audit"],       "additionalProperties": false,       "patternProperties": { "^x-": {} },       "properties": {         "capabilityTiers": {           "type": "array",           "minItems": 1,           "items": {             "type": "string",             "enum": [               "read_only",               "write_local_confirm",               "destructive_two_step",               "network_off_by_default"             ]           }         },         "audit": {           "type": "object",           "required": ["ledgerEnabled", "fields"],           "additionalProperties": false,           "properties": {             "ledgerEnabled": { "type": "boolean" },             "fields": {               "type": "array",               "minItems": 1,               "items": { "type": "string" }             }           }         }       }     },      "ObservabilityContract": {       "type": "object",       "required": ["tracing", "metrics", "logs"],       "additionalProperties": false,       "patternProperties": { "^x-": {} },       "properties": {         "tracing": { "type": "boolean" },         "metrics": {           "type": "array",           "items": { "type": "string" }         },         "logs": {           "type": "object",           "required": ["correlatedBy"],           "additionalProperties": false,           "properties": {             "correlatedBy": { "type": "string", "enum": ["traceId"] }           }         }       }     },      "Kernel": {       "type": "object",       "required": ["id", "api", "stateMachine"],       "additionalProperties": false,       "patternProperties": { "^x-": {} },       "properties": {         "id": { "type": "string", "minLength": 1 },         "api": { "$ref": "#/$defs/KernelApi" },         "stateMachine": { "$ref": "#/$defs/StateMachine" }       }     },      "KernelApi": {       "type": "object",       "required": ["http", "ws"],       "additionalProperties": false,       "properties": {         "http": {           "type": "object",           "required": ["base", "endpoints"],           "additionalProperties": false,           "properties": {             "base": { "type": "string", "minLength": 1 },             "endpoints": {               "type": "array",               "items": { "$ref": "#/$defs/HttpEndpoint" }             }           }         },         "ws": {           "type": "array",           "items": { "$ref": "#/$defs/WsEndpoint" }         }       }     },      "HttpEndpoint": {       "type": "object",       "required": ["path", "method"],       "additionalProperties": false,       "properties": {         "path": { "type": "string", "minLength": 1 },         "method": { "type": "string", "enum": ["GET", "POST", "PUT", "PATCH", "DELETE"] },         "stream": { "type": "boolean" }       }     },      "WsEndpoint": {       "type": "object",       "required": ["path", "direction"],       "additionalProperties": false,       "properties": {         "path": { "type": "string", "minLength": 1 },         "direction": { "type": "string", "enum": ["in", "out", "bi"] },         "stream": { "type": "boolean" }       }     },      "StateMachine": {       "type": "object",       "required": ["states", "transitions"],       "additionalProperties": false,       "properties": {         "states": {           "type": "array",           "minItems": 1,           "items": { "type": "string", "minLength": 1 }         },         "transitions": {           "type": "array",           "minItems": 1,           "items": { "$ref": "#/$defs/Transition" }         }       }     },      "Transition": {       "type": "object",       "required": ["on", "from", "to"],       "additionalProperties": false,       "properties": {         "on": { "type": "string", "minLength": 1 },         "from": { "oneOf": [{ "type": "string" }, { "type": "array", "items": { "type": "string" } }] },         "to": { "type": "string", "minLength": 1 }       }     },      "Skill": {       "type": "object",       "required": ["id", "version", "role", "provides", "consumes", "latencyClass"],       "additionalProperties": false,       "patternProperties": { "^x-": {} },       "properties": {         "id": { "type": "string", "minLength": 1 },         "version": { "type": "string", "minLength": 1 },         "role": { "type": "string", "minLength": 1 },          "transport": { "$ref": "#/$defs/Transport" },          "provides": {           "type": "array",           "items": { "type": "string", "minLength": 1 }         },         "consumes": {           "type": "array",           "items": { "type": "string", "minLength": 1 }         },          "latencyClass": {           "type": "string",           "enum": ["realtime_audio", "realtime_video", "realtime_text", "hybrid", "background"]         },          "resources": { "$ref": "#/$defs/Resources" },          "config": { "type": "object" },          "storage": { "$ref": "#/$defs/Storage" },          "policies": { "type": "object" },          "capabilityTier": {           "type": "string",           "enum": ["read_only", "write_local_confirm", "destructive_two_step", "network_off_by_default"]         },          "actions": {           "type": "array",           "items": { "$ref": "#/$defs/Action" }         },          "auditLedger": { "type": "boolean" }       }     },      "Transport": {       "type": "object",       "required": ["type"],       "additionalProperties": false,       "properties": {         "type": { "type": "string", "enum": ["http", "ws", "inproc"] },         "base": { "type": "string" },         "endpoint": { "type": "string" },         "framework": { "type": "string" }       }     },      "Resources": {       "type": "object",       "additionalProperties": false,       "properties": {         "cpu": { "type": "string", "enum": ["low", "medium", "high", "optional"] },         "gpu": { "type": "string", "enum": ["required", "preferred", "optional", "none"] },         "vram": { "type": "string" }       }     },      "Storage": {       "type": "object",       "required": ["type"],       "additionalProperties": false,       "properties": {         "type": { "type": "string", "enum": ["sqlite", "vectordb", "filesystem", "none"] },         "engine": { "type": "string" },         "path": { "type": "string" }       }     },      "Action": {       "type": "object",       "required": ["name", "params"],       "additionalProperties": false,       "properties": {         "name": { "type": "string", "minLength": 1 },         "params": { "type": "array", "items": { "type": "string" } },         "requiresConfirm": { "type": "boolean" }       }     },      "Pipeline": {       "type": "object",       "required": ["id", "steps"],       "additionalProperties": false,       "patternProperties": { "^x-": {} },       "properties": {         "id": { "type": "string", "minLength": 1 },         "steps": {           "type": "array",           "minItems": 1,           "items": { "$ref": "#/$defs/PipelineStep" }         }       }     },      "PipelineStep": {       "oneOf": [         { "$ref": "#/$defs/StepEmit" },         { "$ref": "#/$defs/StepCall" },         { "$ref": "#/$defs/StepRecv" },         { "$ref": "#/$defs/StepIf" }       ]     },      "StepEmit": {       "type": "object",       "required": ["emit"],       "additionalProperties": false,       "properties": {         "emit": { "type": "string", "minLength": 1 }       }     },      "StepCall": {       "type": "object",       "required": ["call"],       "additionalProperties": false,       "properties": {         "call": { "type": "string", "minLength": 1 },         "stream": { "type": "boolean" },         "optional": { "type": "boolean" },         "mode": { "type": "string" }       }     },      "StepRecv": {       "type": "object",       "required": ["recv"],       "additionalProperties": false,       "properties": {         "recv": { "type": "string", "minLength": 1 },         "via": { "type": "string" }       }     },      "StepIf": {       "type": "object",       "required": ["if", "then"],       "additionalProperties": false,       "properties": {         "if": { "type": "string", "minLength": 1 },         "then": { "type": "string", "minLength": 1 },         "else": { "type": "string" }       }     },      "Acceptance": {       "type": "object",       "additionalProperties": false,       "patternProperties": { "^x-": {} },       "properties": {         "mvp": { "type": "array", "items": { "type": "string" } }       }     }   } } 2) Kanonische Event-Typenliste (Naming + Payload-Shapes) 2.1 Naming-Regeln (damit’s stabil bleibt) Domain.Purpose.Detail (z.B. voice.chunk, tool.request, rag.context)  Streaming immer: stream.start|stream.chunk|stream.end als Hülle (optional), oder als eigene Eventtypen, je nach Transport.  2.2 Event-Katalog (JSON; du kannst das direkt als eventTypes.json ablegen) {   "stream": {     "stream.start": { "payload": { "streamId": "string", "meta": "object" } },     "stream.chunk": { "payload": { "streamId": "string", "seq": "int", "data": "object" } },     "stream.end": { "payload": { "streamId": "string", "reason": "string" } }   },    "voice": {     "voice.start": { "payload": { "sampleRate": "int", "format": "pcm16|f32", "channels": "int" } },     "voice.chunk": { "payload": { "seq": "int", "bytesB64": "string", "ms": "int" } },     "voice.end": { "payload": { "totalMs": "int" } }   },    "stt": {     "stt.partial": { "payload": { "text": "string", "confidence": "number", "final": false } },     "stt.final": { "payload": { "text": "string", "confidence": "number", "final": true } }   },    "chat": {     "chat.query": { "payload": { "text": "string", "locale": "string", "sessionId": "string" } },     "chat.prompt": { "payload": { "messages": "array", "system": "string", "tools": "array" } }   },    "llm": {     "llm.token": { "payload": { "text": "string", "seq": "int" } },     "llm.text": { "payload": { "text": "string" } },     "llm.complete": { "payload": { "text": "string", "usage": "object" } },     "llm.embed": { "payload": { "input": "string|array", "vector": "array<number>" } }   },    "tts": {     "tts.start": { "payload": { "voice": "string", "format": "pcm16|wav|mp3", "sampleRate": "int" } },     "tts.audio": { "payload": { "seq": "int", "bytesB64": "string", "ms": "int" } },     "tts.viseme_timing": { "payload": { "visemes": "array", "timingMs": "array<int>" } },     "tts.end": { "payload": { "totalMs": "int" } }   },    "avatar": {     "avatar.start": { "payload": { "fps": "int", "format": "rgb|yuv", "resolution": "string" } },     "avatar.frame": { "payload": { "seq": "int", "imageB64": "string" } },     "avatar.frames": { "payload": { "frames": "array", "fromSeq": "int" } },     "avatar.end": { "payload": { "totalFrames": "int" } }   },    "rag": {     "rag.query": { "payload": { "text": "string", "topK": "int" } },     "rag.context": {       "payload": {         "hits": [           {             "sourceId": "string",             "title": "string",             "snippet": "string",             "score": "number",             "loc": "object"           }         ]       }     },     "index.request": { "payload": { "paths": "array<string>", "mode": "incremental|full" } },     "index.progress": { "payload": { "done": "int", "total": "int" } }   },    "memory": {     "memory.context": { "payload": { "facts": "array", "summaries": "array" } },     "memory.write": { "payload": { "type": "episodic|semantic", "content": "object", "source": "object" } },     "memory.write.receipt": { "payload": { "id": "string", "ts": "string" } }   },    "tool": {     "tool.request": {       "payload": {         "tool": "string",         "action": "string",         "params": "object",         "capabilityTier": "read_only|write_local_confirm|destructive_two_step|network_off_by_default",         "requiresConfirm": "boolean"       }     },     "tool.result": { "payload": { "ok": "boolean", "data": "object", "error": "object|null" } }   },    "watcher": {     "event.fs.changed": { "payload": { "path": "string", "kind": "create|modify|delete", "ts": "string" } },     "event.system.health": { "payload": { "cpu": "number", "ram": "number", "vram": "number", "disk": "number" } },     "event.git.build_failed": { "payload": { "project": "string", "logPath": "string", "exitCode": "int" } }   },    "proactive": {     "nudge.proposal": {       "payload": {         "title": "string",         "reason": "string",         "severity": "low|medium|high|critical",         "suggestedActions": "array",         "channel": "dashboard_only|toast|voice|avatar"       }     },     "nudge.dispatch": {       "payload": {         "proposalId": "string",         "channel": "dashboard_only|toast|voice|avatar",         "rateLimited": "boolean"       }     }   },    "ui": {     "ui.command": { "payload": { "command": "string", "args": "object" } },     "ui.feedback": { "payload": { "target": "string", "helpful": "boolean", "note": "string" } },     "ui.interruptibility": { "payload": { "mode": "dnd|focus|available" } }   },    "kernel": {     "turn.start": { "payload": { "sessionId": "string", "inputType": "text|voice|event" } },     "turn.end": { "payload": { "sessionId": "string", "outcome": "ok|error" } },     "pipeline.status": { "payload": { "pipelineId": "string", "step": "string", "state": "start|done|error" } }   },    "ledger": {     "ledger.entry": {       "payload": {         "actorSkill": "string",         "action": "string",         "targets": "array<string>",         "beforeHash": "string",         "afterHash": "string",         "ts": "string"       }     }   },    "error": {     "error.raised": {       "payload": {         "code": "string",         "message": "string",         "details": "object",         "recoverable": "boolean"       }     }   } } Wenn du als nächsten Schritt willst, kann ich dir daraus konkrete TypeScript-Typen (für Next.js Dashboard + WS Messages) und Python Pydantic Models (für FastAPI) ableiten – dann sind Manifest + Events sofort „compile-time enforced“.  Du: ja 1.PHASE-START_DYAI_IdeaGPT sagte:  Nachgedacht für 19s Alles klar — hier sind (A) TypeScript-Typen (für Next.js/WS) und (B) Python Pydantic Models (für FastAPI), direkt passend zu deinem Envelope-Contract (type/traceId/ts/source/severity/payload) + den Eventtypen.  A) TypeScript (Next.js / WebSocket / Client & Server) contracts.ts // contracts.ts export type Severity = "debug" | "info" | "warn" | "error";  export type CapabilityTier =   | "read_only"   | "write_local_confirm"   | "destructive_two_step"   | "network_off_by_default";  export type InterruptMode = "dnd" | "focus" | "available";  export interface ResultEnvelope<T> {   ok: true;   data: T; }  export interface ErrorEnvelope {   ok: false;   error: {     code:       | "E_BAD_REQUEST"       | "E_PERMISSION_REQUIRED"       | "E_VALIDATION"       | "E_IO"       | "E_RESOURCE_LIMIT"       | "E_DEPENDENCY_UNAVAILABLE"       | "E_TIMEOUT"       | "E_UNKNOWN";     message: string;     details?: unknown;   }; }  export type ApiResult<T> = ResultEnvelope<T> | ErrorEnvelope;  export interface BaseEventEnvelope<TType extends string, TPayload> {   type: TType;   traceId: string;   ts: string;      // ISO-8601   source: string;  // e.g. "skill.voice.stt" | "kernel" | "ui.dashboard"   severity: Severity;   payload: TPayload; } events.ts (Event-Payload-Map + strikte Union) // events.ts import { BaseEventEnvelope, CapabilityTier, InterruptMode } from "./contracts";  /** 1) Payload Shapes */ export type StreamStartPayload = { streamId: string; meta?: Record<string, unknown> }; export type StreamChunkPayload = { streamId: string; seq: number; data: Record<string, unknown> }; export type StreamEndPayload = { streamId: string; reason?: string };  export type VoiceStartPayload = { sampleRate: number; format: "pcm16" | "f32"; channels: number }; export type VoiceChunkPayload = { seq: number; bytesB64: string; ms: number }; export type VoiceEndPayload = { totalMs: number };  export type SttPartialPayload = { text: string; confidence: number; final: false }; export type SttFinalPayload = { text: string; confidence: number; final: true };  export type ChatQueryPayload = { text: string; locale?: string; sessionId: string }; export type ChatPromptPayload = { messages: unknown[]; system?: string; tools?: unknown[] };  export type LlmTokenPayload = { text: string; seq: number }; export type LlmTextPayload = { text: string }; export type LlmCompletePayload = { text: string; usage?: Record<string, unknown> };  export type TtsStartPayload = {   voice: string;   format: "pcm16" | "wav" | "mp3";   sampleRate: number; }; export type TtsAudioPayload = { seq: number; bytesB64: string; ms: number }; export type TtsVisemeTimingPayload = { visemes: unknown[]; timingMs: number[] }; export type TtsEndPayload = { totalMs: number };  export type AvatarStartPayload = { fps: number; format: "rgb" | "yuv"; resolution: string }; export type AvatarFramePayload = { seq: number; imageB64: string }; export type AvatarEndPayload = { totalFrames: number };  export type RagQueryPayload = { text: string; topK?: number }; export type RagContextPayload = {   hits: Array<{     sourceId: string;     title?: string;     snippet: string;     score: number;     loc?: Record<string, unknown>;   }>; };  export type ToolRequestPayload = {   tool: string;   action: string;   params: Record<string, unknown>;   capabilityTier: CapabilityTier;   requiresConfirm: boolean; }; export type ToolResultPayload = { ok: boolean; data?: Record<string, unknown>; error?: unknown | null };  export type FsChangedPayload = { path: string; kind: "create" | "modify" | "delete"; ts: string }; export type SystemHealthPayload = { cpu: number; ram: number; vram: number; disk: number }; export type GitBuildFailedPayload = { project: string; logPath: string; exitCode: number };  export type NudgeProposalPayload = {   title: string;   reason: string;   severity: "low" | "medium" | "high" | "critical";   suggestedActions?: unknown[];   channel: "dashboard_only" | "toast" | "voice" | "avatar"; }; export type NudgeDispatchPayload = {   proposalId: string;   channel: "dashboard_only" | "toast" | "voice" | "avatar";   rateLimited: boolean; };  export type UiCommandPayload = { command: string; args?: Record<string, unknown> }; export type UiFeedbackPayload = { target: string; helpful: boolean; note?: string }; export type UiInterruptibilityPayload = { mode: InterruptMode };  export type TurnStartPayload = { sessionId: string; inputType: "text" | "voice" | "event" }; export type TurnEndPayload = { sessionId: string; outcome: "ok" | "error" }; export type PipelineStatusPayload = {   pipelineId: string;   step: string;   state: "start" | "done" | "error"; };  export type LedgerEntryPayload = {   actorSkill: string;   action: string;   targets: string[];   beforeHash?: string;   afterHash?: string;   ts: string; };  export type ErrorRaisedPayload = {   code: string;   message: string;   details?: Record<string, unknown>;   recoverable: boolean; };  /** 2) Payload Map (single source in TS) */ export interface EventPayloadMap {   "stream.start": StreamStartPayload;   "stream.chunk": StreamChunkPayload;   "stream.end": StreamEndPayload;    "voice.start": VoiceStartPayload;   "voice.chunk": VoiceChunkPayload;   "voice.end": VoiceEndPayload;    "stt.partial": SttPartialPayload;   "stt.final": SttFinalPayload;    "chat.query": ChatQueryPayload;   "chat.prompt": ChatPromptPayload;    "llm.token": LlmTokenPayload;   "llm.text": LlmTextPayload;   "llm.complete": LlmCompletePayload;    "tts.start": TtsStartPayload;   "tts.audio": TtsAudioPayload;   "tts.viseme_timing": TtsVisemeTimingPayload;   "tts.end": TtsEndPayload;    "avatar.start": AvatarStartPayload;   "avatar.frame": AvatarFramePayload;   "avatar.end": AvatarEndPayload;    "rag.query": RagQueryPayload;   "rag.context": RagContextPayload;    "tool.request": ToolRequestPayload;   "tool.result": ToolResultPayload;    "event.fs.changed": FsChangedPayload;   "event.system.health": SystemHealthPayload;   "event.git.build_failed": GitBuildFailedPayload;    "nudge.proposal": NudgeProposalPayload;   "nudge.dispatch": NudgeDispatchPayload;    "ui.command": UiCommandPayload;   "ui.feedback": UiFeedbackPayload;   "ui.interruptibility": UiInterruptibilityPayload;    "turn.start": TurnStartPayload;   "turn.end": TurnEndPayload;   "pipeline.status": PipelineStatusPayload;    "ledger.entry": LedgerEntryPayload;   "error.raised": ErrorRaisedPayload; }  export type EventType = keyof EventPayloadMap;  /** 3) Typed Envelope */ export type EventEnvelope<T extends EventType = EventType> = BaseEventEnvelope<   T,   EventPayloadMap[T] >;  /** 4) Discriminated Union (nice for switch(type)) */ export type AnyEvent = {   [K in EventType]: EventEnvelope<K>; }[EventType];  /** 5) Helper */ export function makeEvent<T extends EventType>(e: EventEnvelope<T>): EventEnvelope<T> {   return e; } Mini-Nutzung (WS-Handler) import { AnyEvent } from "./events";  export function handleEvent(ev: AnyEvent) {   switch (ev.type) {     case "voice.chunk":       // ev.payload is VoiceChunkPayload       return;     case "tool.request":       // ev.payload is ToolRequestPayload       return;     default:       return;   } } B) Python (FastAPI + Pydantic, diskriminierte Union über type) ✅ Funktioniert sauber mit Pydantic v2 (empfohlen). Falls du noch v1 nutzt, sag kurz Bescheid – ich gebe dir die v1-Variante.  schemas.py from __future__ import annotations  from datetime import datetime from typing import Any, Dict, List, Literal, Optional, Union, Annotated  from pydantic import BaseModel, Field, ConfigDict   # ------------------------- # Shared Contracts # -------------------------  Severity = Literal["debug", "info", "warn", "error"]  ErrorCode = Literal[     "E_BAD_REQUEST",     "E_PERMISSION_REQUIRED",     "E_VALIDATION",     "E_IO",     "E_RESOURCE_LIMIT",     "E_DEPENDENCY_UNAVAILABLE",     "E_TIMEOUT",     "E_UNKNOWN", ]  CapabilityTier = Literal[     "read_only",     "write_local_confirm",     "destructive_two_step",     "network_off_by_default", ]  InterruptMode = Literal["dnd", "focus", "available"]   class ErrorDetail(BaseModel):     code: ErrorCode     message: str     details: Optional[Any] = None   class ResultOk(BaseModel):     ok: Literal[True] = True     data: Any   class ResultFail(BaseModel):     ok: Literal[False] = False     error: ErrorDetail   ApiResult = Union[ResultOk, ResultFail]   class EventEnvelopeBase(BaseModel):     """     Base envelope (type + payload provided by subclasses for discriminator).     """     model_config = ConfigDict(populate_by_name=True)      type: str     trace_id: str = Field(alias="traceId")     ts: datetime     source: str     severity: Severity     payload: Any   # ------------------------- # Payload Models # -------------------------  class StreamStartPayload(BaseModel):     streamId: str     meta: Optional[Dict[str, Any]] = None  class StreamChunkPayload(BaseModel):     streamId: str     seq: int     data: Dict[str, Any]  class StreamEndPayload(BaseModel):     streamId: str     reason: Optional[str] = None   class VoiceStartPayload(BaseModel):     sampleRate: int     format: Literal["pcm16", "f32"]     channels: int  class VoiceChunkPayload(BaseModel):     seq: int     bytesB64: str     ms: int  class VoiceEndPayload(BaseModel):     totalMs: int   class SttPartialPayload(BaseModel):     text: str     confidence: float     final: Literal[False] = False  class SttFinalPayload(BaseModel):     text: str     confidence: float     final: Literal[True] = True   class ChatQueryPayload(BaseModel):     text: str     locale: Optional[str] = None     sessionId: str  class ChatPromptPayload(BaseModel):     messages: List[Any]     system: Optional[str] = None     tools: Optional[List[Any]] = None   class LlmTokenPayload(BaseModel):     text: str     seq: int  class LlmTextPayload(BaseModel):     text: str  class LlmCompletePayload(BaseModel):     text: str     usage: Optional[Dict[str, Any]] = None   class TtsStartPayload(BaseModel):     voice: str     format: Literal["pcm16", "wav", "mp3"]     sampleRate: int  class TtsAudioPayload(BaseModel):     seq: int     bytesB64: str     ms: int  class TtsVisemeTimingPayload(BaseModel):     visemes: List[Any]     timingMs: List[int]  class TtsEndPayload(BaseModel):     totalMs: int   class AvatarStartPayload(BaseModel):     fps: int     format: Literal["rgb", "yuv"]     resolution: str  class AvatarFramePayload(BaseModel):     seq: int     imageB64: str  class AvatarEndPayload(BaseModel):     totalFrames: int   class RagQueryPayload(BaseModel):     text: str     topK: Optional[int] = None  class RagHit(BaseModel):     sourceId: str     title: Optional[str] = None     snippet: str     score: float     loc: Optional[Dict[str, Any]] = None  class RagContextPayload(BaseModel):     hits: List[RagHit]   class ToolRequestPayload(BaseModel):     tool: str     action: str     params: Dict[str, Any]     capabilityTier: CapabilityTier     requiresConfirm: bool  class ToolResultPayload(BaseModel):     ok: bool     data: Optional[Dict[str, Any]] = None     error: Optional[Any] = None   class FsChangedPayload(BaseModel):     path: str     kind: Literal["create", "modify", "delete"]     ts: datetime  class SystemHealthPayload(BaseModel):     cpu: float     ram: float     vram: float     disk: float  class GitBuildFailedPayload(BaseModel):     project: str     logPath: str     exitCode: int   NudgeChannel = Literal["dashboard_only", "toast", "voice", "avatar"] NudgeSeverity = Literal["low", "medium", "high", "critical"]  class NudgeProposalPayload(BaseModel):     title: str     reason: str     severity: NudgeSeverity     suggestedActions: Optional[List[Any]] = None     channel: NudgeChannel  class NudgeDispatchPayload(BaseModel):     proposalId: str     channel: NudgeChannel     rateLimited: bool   class UiCommandPayload(BaseModel):     command: str     args: Optional[Dict[str, Any]] = None  class UiFeedbackPayload(BaseModel):     target: str     helpful: bool     note: Optional[str] = None  class UiInterruptibilityPayload(BaseModel):     mode: InterruptMode   class TurnStartPayload(BaseModel):     sessionId: str     inputType: Literal["text", "voice", "event"]  class TurnEndPayload(BaseModel):     sessionId: str     outcome: Literal["ok", "error"]  class PipelineStatusPayload(BaseModel):     pipelineId: str     step: str     state: Literal["start", "done", "error"]   class LedgerEntryPayload(BaseModel):     actorSkill: str     action: str     targets: List[str]     beforeHash: Optional[str] = None     afterHash: Optional[str] = None     ts: datetime   class ErrorRaisedPayload(BaseModel):     code: str     message: str     details: Optional[Dict[str, Any]] = None     recoverable: bool   # ------------------------- # Event Models (discriminated by "type") # -------------------------  class StreamStartEvent(EventEnvelopeBase):     type: Literal["stream.start"]     payload: StreamStartPayload  class StreamChunkEvent(EventEnvelopeBase):     type: Literal["stream.chunk"]     payload: StreamChunkPayload  class StreamEndEvent(EventEnvelopeBase):     type: Literal["stream.end"]     payload: StreamEndPayload   class VoiceStartEvent(EventEnvelopeBase):     type: Literal["voice.start"]     payload: VoiceStartPayload  class VoiceChunkEvent(EventEnvelopeBase):     type: Literal["voice.chunk"]     payload: VoiceChunkPayload  class VoiceEndEvent(EventEnvelopeBase):     type: Literal["voice.end"]     payload: VoiceEndPayload   class SttPartialEvent(EventEnvelopeBase):     type: Literal["stt.partial"]     payload: SttPartialPayload  class SttFinalEvent(EventEnvelopeBase):     type: Literal["stt.final"]     payload: SttFinalPayload   class ChatQueryEvent(EventEnvelopeBase):     type: Literal["chat.query"]     payload: ChatQueryPayload  class ChatPromptEvent(EventEnvelopeBase):     type: Literal["chat.prompt"]     payload: ChatPromptPayload   class LlmTokenEvent(EventEnvelopeBase):     type: Literal["llm.token"]     payload: LlmTokenPayload  class LlmTextEvent(EventEnvelopeBase):     type: Literal["llm.text"]     payload: LlmTextPayload  class LlmCompleteEvent(EventEnvelopeBase):     type: Literal["llm.complete"]     payload: LlmCompletePayload   class TtsStartEvent(EventEnvelopeBase):     type: Literal["tts.start"]     payload: TtsStartPayload  class TtsAudioEvent(EventEnvelopeBase):     type: Literal["tts.audio"]     payload: TtsAudioPayload  class TtsVisemeTimingEvent(EventEnvelopeBase):     type: Literal["tts.viseme_timing"]     payload: TtsVisemeTimingPayload  class TtsEndEvent(EventEnvelopeBase):     type: Literal["tts.end"]     payload: TtsEndPayload   class AvatarStartEvent(EventEnvelopeBase):     type: Literal["avatar.start"]     payload: AvatarStartPayload  class AvatarFrameEvent(EventEnvelopeBase):     type: Literal["avatar.frame"]     payload: AvatarFramePayload  class AvatarEndEvent(EventEnvelopeBase):     type: Literal["avatar.end"]     payload: AvatarEndPayload   class RagQueryEvent(EventEnvelopeBase):     type: Literal["rag.query"]     payload: RagQueryPayload  class RagContextEvent(EventEnvelopeBase):     type: Literal["rag.context"]     payload: RagContextPayload   class ToolRequestEvent(EventEnvelopeBase):     type: Literal["tool.request"]     payload: ToolRequestPayload  class ToolResultEvent(EventEnvelopeBase):     type: Literal["tool.result"]     payload: ToolResultPayload   class FsChangedEvent(EventEnvelopeBase):     type: Literal["event.fs.changed"]     payload: FsChangedPayload  class SystemHealthEvent(EventEnvelopeBase):     type: Literal["event.system.health"]     payload: SystemHealthPayload  class GitBuildFailedEvent(EventEnvelopeBase):     type: Literal["event.git.build_failed"]     payload: GitBuildFailedPayload   class NudgeProposalEvent(EventEnvelopeBase):     type: Literal["nudge.proposal"]     payload: NudgeProposalPayload  class NudgeDispatchEvent(EventEnvelopeBase):     type: Literal["nudge.dispatch"]     payload: NudgeDispatchPayload   class UiCommandEvent(EventEnvelopeBase):     type: Literal["ui.command"]     payload: UiCommandPayload  class UiFeedbackEvent(EventEnvelopeBase):     type: Literal["ui.feedback"]     payload: UiFeedbackPayload  class UiInterruptibilityEvent(EventEnvelopeBase):     type: Literal["ui.interruptibility"]     payload: UiInterruptibilityPayload   class TurnStartEvent(EventEnvelopeBase):     type: Literal["turn.start"]     payload: TurnStartPayload  class TurnEndEvent(EventEnvelopeBase):     type: Literal["turn.end"]     payload: TurnEndPayload  class PipelineStatusEvent(EventEnvelopeBase):     type: Literal["pipeline.status"]     payload: PipelineStatusPayload   class LedgerEntryEvent(EventEnvelopeBase):     type: Literal["ledger.entry"]     payload: LedgerEntryPayload   class ErrorRaisedEvent(EventEnvelopeBase):     type: Literal["error.raised"]     payload: ErrorRaisedPayload   AnyEvent = Annotated[     Union[         StreamStartEvent, StreamChunkEvent, StreamEndEvent,         VoiceStartEvent, VoiceChunkEvent, VoiceEndEvent,         SttPartialEvent, SttFinalEvent,         ChatQueryEvent, ChatPromptEvent,         LlmTokenEvent, LlmTextEvent, LlmCompleteEvent,         TtsStartEvent, TtsAudioEvent, TtsVisemeTimingEvent, TtsEndEvent,         AvatarStartEvent, AvatarFrameEvent, AvatarEndEvent,         RagQueryEvent, RagContextEvent,         ToolRequestEvent, ToolResultEvent,         FsChangedEvent, SystemHealthEvent, GitBuildFailedEvent,         NudgeProposalEvent, NudgeDispatchEvent,         UiCommandEvent, UiFeedbackEvent, UiInterruptibilityEvent,         TurnStartEvent, TurnEndEvent, PipelineStatusEvent,         LedgerEntryEvent,         ErrorRaisedEvent,     ],     Field(discriminator="type"), ] (Optional) FastAPI Stub, damit du sofort siehst wie’s „wired“ wird from fastapi import FastAPI, WebSocket from schemas import AnyEvent  app = FastAPI()  @app.post("/events") def ingest_event(ev: AnyEvent):     # switch-like routing:     if ev.type == "tool.request":         # ev.payload is ToolRequestPayload (typed)         return {"ok": True, "data": {"accepted": True}}     return {"ok": True, "data": {"received": ev.type}}  @app.websocket("/ws/voice") async def ws_voice(ws: WebSocket):     await ws.accept()     while True:         msg = await ws.receive_json()         ev = AnyEvent.__pydantic_validator__.validate_python(msg)  # pydantic v2 parse         # handle ev...         await ws.send_json({"ok": True, "data": {"echo": ev.type}}) Wenn du als nächsten Schritt „richtig rund“ willst: ich kann dir daraus 1:1 Codegen-fähige Struktur machen (ein event_types.json als Single Source of Truth + Generator-Skripte), sodass TS & Python niemals driften.  Du: ja 1.PHASE-START_DYAI_IdeaGPT sagte:  Nachgedacht für 26s  Analysiert Details immer anzeigen  import json, os, textwrap, re from datetime import datetime  out_dir = "/mnt/data/generated" os.makedirs(out_dir, exist_ok=True)  catalog = {   "catalogVersion": "0.1",   "envelope": {     "fields": ["type","traceId","ts","source","severity","payload"],     "severityEnum": ["debug","info","warn","error"]   },   "primitives": ["string","int","float","boolean","datetime","any"],   "payloadTypes": {     "StreamStartPayload": {       "streamId": {"type":"string"},       "meta": {"type":"record", "optional": True, "values":{"type":"any"}}     },     "StreamChunkPayload": {       "streamId": {"type":"string"},       "seq": {"type":"int"},       "data": {"type":"record", "values":{"type":"any"}}     },     "StreamEndPayload": {       "streamId": {"type":"string"},       "reason": {"type":"string", "optional": True}     },      "VoiceStartPayload": {       "sampleRate": {"type":"int"},       "format": {"type":"enum", "values":["pcm16","f32"]},       "channels": {"type":"int"}     },     "VoiceChunkPayload": {       "seq": {"type":"int"},       "bytesB64": {"type":"string"},       "ms": {"type":"int"}     },     "VoiceEndPayload": {       "totalMs": {"type":"int"}     },      "SttPartialPayload": {       "text": {"type":"string"},       "confidence": {"type":"float"},       "final": {"type":"literal", "value": False}     },     "SttFinalPayload": {       "text": {"type":"string"},       "confidence": {"type":"float"},       "final": {"type":"literal", "value": True}     },      "ChatQueryPayload": {       "text": {"type":"string"},       "locale": {"type":"string", "optional": True},       "sessionId": {"type":"string"}     },     "ChatPromptPayload": {       "messages": {"type":"array", "items":{"type":"any"}},       "system": {"type":"string", "optional": True},       "tools": {"type":"array", "optional": True, "items":{"type":"any"}}     },      "LlmTokenPayload": {       "text": {"type":"string"},       "seq": {"type":"int"}     },     "LlmTextPayload": {       "text": {"type":"string"}     },     "LlmCompletePayload": {       "text": {"type":"string"},       "usage": {"type":"record", "optional": True, "values":{"type":"any"}}     },      "TtsStartPayload": {       "voice": {"type":"string"},       "format": {"type":"enum", "values":["pcm16","wav","mp3"]},       "sampleRate": {"type":"int"}     },     "TtsAudioPayload": {       "seq": {"type":"int"},       "bytesB64": {"type":"string"},       "ms": {"type":"int"}     },     "TtsVisemeTimingPayload": {       "visemes": {"type":"array", "items":{"type":"any"}},       "timingMs": {"type":"array", "items":{"type":"int"}}     },     "TtsEndPayload": {       "totalMs": {"type":"int"}     },      "AvatarStartPayload": {       "fps": {"type":"int"},       "format": {"type":"enum", "values":["rgb","yuv"]},       "resolution": {"type":"string"}     },     "AvatarFramePayload": {       "seq": {"type":"int"},       "imageB64": {"type":"string"}     },     "AvatarEndPayload": {       "totalFrames": {"type":"int"}     },      "RagQueryPayload": {       "text": {"type":"string"},       "topK": {"type":"int", "optional": True}     },     "RagHit": {       "sourceId": {"type":"string"},       "title": {"type":"string", "optional": True},       "snippet": {"type":"string"},       "score": {"type":"float"},       "loc": {"type":"record", "optional": True, "values":{"type":"any"}}     },     "RagContextPayload": {       "hits": {"type":"array", "items":{"type":"ref", "name":"RagHit"}}     },      "ToolRequestPayload": {       "tool": {"type":"string"},       "action": {"type":"string"},       "params": {"type":"record", "values":{"type":"any"}},       "capabilityTier": {"type":"enum", "values":["read_only","write_local_confirm","destructive_two_step","network_off_by_default"]},       "requiresConfirm": {"type":"boolean"}     },     "ToolResultPayload": {       "ok": {"type":"boolean"},       "data": {"type":"record", "optional": True, "values":{"type":"any"}},       "error": {"type":"any", "optional": True}     },      "FsChangedPayload": {       "path": {"type":"string"},       "kind": {"type":"enum", "values":["create","modify","delete"]},       "ts": {"type":"datetime"}     },     "SystemHealthPayload": {       "cpu": {"type":"float"},       "ram": {"type":"float"},       "vram": {"type":"float"},       "disk": {"type":"float"}     },     "GitBuildFailedPayload": {       "project": {"type":"string"},       "logPath": {"type":"string"},       "exitCode": {"type":"int"}     },      "NudgeProposalPayload": {       "title": {"type":"string"},       "reason": {"type":"string"},       "severity": {"type":"enum", "values":["low","medium","high","critical"]},       "suggestedActions": {"type":"array", "optional": True, "items":{"type":"any"}},       "channel": {"type":"enum", "values":["dashboard_only","toast","voice","avatar"]}     },     "NudgeDispatchPayload": {       "proposalId": {"type":"string"},       "channel": {"type":"enum", "values":["dashboard_only","toast","voice","avatar"]},       "rateLimited": {"type":"boolean"}     },      "UiCommandPayload": {       "command": {"type":"string"},       "args": {"type":"record", "optional": True, "values":{"type":"any"}}     },     "UiFeedbackPayload": {       "target": {"type":"string"},       "helpful": {"type":"boolean"},       "note": {"type":"string", "optional": True}     },     "UiInterruptibilityPayload": {       "mode": {"type":"enum", "values":["dnd","focus","available"]}     },      "TurnStartPayload": {       "sessionId": {"type":"string"},       "inputType": {"type":"enum", "values":["text","voice","event"]}     },     "TurnEndPayload": {       "sessionId": {"type":"string"},       "outcome": {"type":"enum", "values":["ok","error"]}     },     "PipelineStatusPayload": {       "pipelineId": {"type":"string"},       "step": {"type":"string"},       "state": {"type":"enum", "values":["start","done","error"]}     },      "LedgerEntryPayload": {       "actorSkill": {"type":"string"},       "action": {"type":"string"},       "targets": {"type":"array", "items":{"type":"string"}},       "beforeHash": {"type":"string", "optional": True},       "afterHash": {"type":"string", "optional": True},       "ts": {"type":"datetime"}     },      "ErrorRaisedPayload": {       "code": {"type":"string"},       "message": {"type":"string"},       "details": {"type":"record", "optional": True, "values":{"type":"any"}},       "recoverable": {"type":"boolean"}     }   },    "events": {     "stream.start": {"payload": "StreamStartPayload"},     "stream.chunk": {"payload": "StreamChunkPayload"},     "stream.end": {"payload": "StreamEndPayload"},      "voice.start": {"payload": "VoiceStartPayload"},     "voice.chunk": {"payload": "VoiceChunkPayload"},     "voice.end": {"payload": "VoiceEndPayload"},      "stt.partial": {"payload": "SttPartialPayload"},     "stt.final": {"payload": "SttFinalPayload"},      "chat.query": {"payload": "ChatQueryPayload"},     "chat.prompt": {"payload": "ChatPromptPayload"},      "llm.token": {"payload": "LlmTokenPayload"},     "llm.text": {"payload": "LlmTextPayload"},     "llm.complete": {"payload": "LlmCompletePayload"},      "tts.start": {"payload": "TtsStartPayload"},     "tts.audio": {"payload": "TtsAudioPayload"},     "tts.viseme_timing": {"payload": "TtsVisemeTimingPayload"},     "tts.end": {"payload": "TtsEndPayload"},      "avatar.start": {"payload": "AvatarStartPayload"},     "avatar.frame": {"payload": "AvatarFramePayload"},     "avatar.end": {"payload": "AvatarEndPayload"},      "rag.query": {"payload": "RagQueryPayload"},     "rag.context": {"payload": "RagContextPayload"},      "tool.request": {"payload": "ToolRequestPayload"},     "tool.result": {"payload": "ToolResultPayload"},      "event.fs.changed": {"payload": "FsChangedPayload"},     "event.system.health": {"payload": "SystemHealthPayload"},     "event.git.build_failed": {"payload": "GitBuildFailedPayload"},      "nudge.proposal": {"payload": "NudgeProposalPayload"},     "nudge.dispatch": {"payload": "NudgeDispatchPayload"},      "ui.command": {"payload": "UiCommandPayload"},     "ui.feedback": {"payload": "UiFeedbackPayload"},     "ui.interruptibility": {"payload": "UiInterruptibilityPayload"},      "turn.start": {"payload": "TurnStartPayload"},     "turn.end": {"payload": "TurnEndPayload"},     "pipeline.status": {"payload": "PipelineStatusPayload"},      "ledger.entry": {"payload": "LedgerEntryPayload"},     "error.raised": {"payload": "ErrorRaisedPayload"}   } }  catalog_path = "/mnt/data/event_catalog.json" with open(catalog_path, "w", encoding="utf-8") as f:     json.dump(catalog, f, indent=2, ensure_ascii=False)  gen_script = r''' #!/usr/bin/env python3 """ Generate TypeScript + Python (Pydantic v2) types from a single source of truth event catalog.  Usage:   python generate_events.py event_catalog.json --out ./generated """ from __future__ import annotations  import argparse, json, os, re from dataclasses import dataclass from typing import Any, Dict, List, Optional  def pascal(s: str) -> str:     # "voice.chunk" -> "VoiceChunk"     parts = re.split(r'[^a-zA-Z0-9]+', s)     return "".join(p[:1].upper() + p[1:] for p in parts if p)  # ------------------------- # TS mapping # ------------------------- def ts_type(spec: Dict[str, Any]) -> str:     t = spec["type"]     if t == "string": return "string"     if t in ("int","float"): return "number"     if t == "boolean": return "boolean"     if t == "datetime": return "string"  # ISO string     if t == "any": return "unknown"     if t == "record":         v = ts_type(spec.get("values", {"type":"any"}))         return f"Record<string, {v}>"     if t == "array":         it = ts_type(spec["items"])         return f"Array<{it}>"     if t == "enum":         vals = spec["values"]         return " | ".join([json.dumps(v) for v in vals])     if t == "literal":         return json.dumps(spec["value"])     if t == "ref":         return spec["name"]     raise ValueError(f"Unknown type spec: {spec}")  # ------------------------- # PY mapping (Pydantic v2) # ------------------------- def py_type(spec: Dict[str, Any]) -> str:     t = spec["type"]     if t == "string": return "str"     if t == "int": return "int"     if t == "float": return "float"     if t == "boolean": return "bool"     if t == "datetime": return "datetime"     if t == "any": return "Any"     if t == "record":         v = py_type(spec.get("values", {"type":"any"}))         return f"Dict[str, {v}]"     if t == "array":         it = py_type(spec["items"])         return f"List[{it}]"     if t == "enum":         vals = spec["values"]         return f"Literal[{', '.join([json.dumps(v) for v in vals])}]"     if t == "literal":         return f"Literal[{json.dumps(spec['value'])}]"     if t == "ref":         return spec["name"]     raise ValueError(f"Unknown type spec: {spec}")  def is_optional(spec: Dict[str, Any]) -> bool:     return bool(spec.get("optional", False))  def write_file(path: str, content: str) -> None:     os.makedirs(os.path.dirname(path), exist_ok=True)     with open(path, "w", encoding="utf-8") as f:         f.write(content)  def gen_ts(catalog: Dict[str, Any]) -> str:     payload_types = catalog["payloadTypes"]     events = catalog["events"]      lines: List[str] = []     lines.append("// AUTO-GENERATED. DO NOT EDIT.\n")      # Shared contracts     sev = catalog["envelope"]["severityEnum"]     lines.append(f'export type Severity = {" | ".join([json.dumps(s) for s in sev])};\n')     lines.append('export interface BaseEventEnvelope<TType extends string, TPayload> {\n'                  '  type: TType;\n'                  '  traceId: string;\n'                  '  ts: string; // ISO-8601\n'                  '  source: string;\n'                  '  severity: Severity;\n'                  '  payload: TPayload;\n'                  '}\n\n')      # Payload interfaces     for name, fields in payload_types.items():         lines.append(f"export interface {name} {{")         for fname, spec in fields.items():             opt = "?" if is_optional(spec) else ""             lines.append(f"  {fname}{opt}: {ts_type(spec)};")         lines.append("}\n")      # EventPayloadMap     lines.append("export interface EventPayloadMap {")     for etype, meta in events.items():         payload = meta["payload"]         lines.append(f"  {json.dumps(etype)}: {payload};")     lines.append("}\n")      lines.append("export type EventType = keyof EventPayloadMap;\n")     lines.append("export type EventEnvelope<T extends EventType = EventType> = BaseEventEnvelope<T, EventPayloadMap[T]>;\n")     lines.append("export type AnyEvent = { [K in EventType]: EventEnvelope<K> }[EventType];\n")     lines.append("export const makeEvent = <T extends EventType>(e: EventEnvelope<T>) => e;\n")     return "\n".join(lines)  def gen_py(catalog: Dict[str, Any]) -> str:     payload_types = catalog["payloadTypes"]     events = catalog["events"]      lines: List[str] = []     lines.append("# AUTO-GENERATED. DO NOT EDIT.\n")     lines.append("from __future__ import annotations\n")     lines.append("from datetime import datetime\n")     lines.append("from typing import Any, Dict, List, Optional, Union, Literal, Annotated\n")     lines.append("from pydantic import BaseModel, Field, ConfigDict\n\n")      # Envelope base     lines.append("Severity = Literal[" + ", ".join([json.dumps(s) for s in catalog["envelope"]["severityEnum"]]) + "]\n\n")      lines.append("class EventEnvelopeBase(BaseModel):\n"                  "    model_config = ConfigDict(populate_by_name=True)\n\n"                  "    type: str\n"                  "    trace_id: str = Field(alias='traceId')\n"                  "    ts: datetime\n"                  "    source: str\n"                  "    severity: Severity\n"                  "    payload: Any\n\n")      # Payload models     for name, fields in payload_types.items():         lines.append(f"class {name}(BaseModel):")         if not fields:             lines.append("    pass\n")             continue         for fname, spec in fields.items():             t = py_type(spec)             if is_optional(spec):                 lines.append(f"    {fname}: Optional[{t}] = None")             else:                 lines.append(f"    {fname}: {t}")         lines.append("")      # Event models     event_class_names: List[str] = []     for etype, meta in events.items():         payload = meta["payload"]         cname = pascal(etype) + "Event"         event_class_names.append(cname)         lines.append(f"class {cname}(EventEnvelopeBase):")         lines.append(f"    type: Literal[{json.dumps(etype)}]")         lines.append(f"    payload: {payload}\n")      # Discriminated union     lines.append("AnyEvent = Annotated[Union[")     for i, cname in enumerate(event_class_names):         comma = "," if i < len(event_class_names) - 1 else ""         lines.append(f"    {cname}{comma}")     lines.append("], Field(discriminator='type')]\n")     return "\n".join(lines)  def main() -> None:     ap = argparse.ArgumentParser()     ap.add_argument("catalog", help="Path to event_catalog.json")     ap.add_argument("--out", default="./generated", help="Output directory")     args = ap.parse_args()      with open(args.catalog, "r", encoding="utf-8") as f:         catalog = json.load(f)      ts_out = os.path.join(args.out, "events.generated.ts")     py_out = os.path.join(args.out, "schemas_generated.py")      write_file(ts_out, gen_ts(catalog))     write_file(py_out, gen_py(catalog))      print(f"Wrote:\n  {ts_out}\n  {py_out}")  if __name__ == "__main__":     main() ''' gen_path = "/mnt/data/generate_events.py" with open(gen_path, "w", encoding="utf-8") as f:     f.write(gen_script)  # run generator to create outputs import subprocess, sys, pathlib, shutil, os subprocess.run(["python", gen_path, catalog_path, "--out", out_dir], check=True)  catalog_path, gen_path, os.path.join(out_dir, "events.generated.ts"), os.path.join(out_dir, "schemas_generated.py")  STDOUT/STDERR Wrote:   /mnt/data/generated/events.generated.ts   /mnt/data/generated/schemas_generated.py Ergebnis ('/mnt/data/event_catalog.json',  '/mnt/data/generate_events.py',  '/mnt/data/generated/events.generated.ts',  '/mnt/data/generated/schemas_generated.py') Perfekt — ich habe dir jetzt eine Single Source of Truth gebaut (event_catalog.json) + Generator (generate_events.py) und daraus bereits die generierten Dateien erstellt (TS + Pydantic).  Downloads event_catalog.json  generate_events.py  events.generated.ts  schemas_generated.py  So benutzt du’s in deinem Repo 1) Generator laufen lassen python generate_events.py event_catalog.json --out ./generated 2) Next.js / TypeScript importieren import { AnyEvent, EventEnvelope, makeEvent } from "./generated/events.generated"; 3) FastAPI / Python importieren from generated.schemas_generated import AnyEvent Und in FastAPI:  @app.post("/events") def ingest_event(ev: AnyEvent):     if ev.type == "tool.request":         return {"ok": True, "data": {"accepted": True}}     return {"ok": True, "data": {"received": ev.type}} Mini-Konvention (damit’s nicht driftet) Nur event_catalog.json wird manuell gepflegt.  TS & Python werden immer daraus generiert.  Wenn du neue Events/Skills ergänzst: payloadTypes erweitern → events referenzieren → generator laufen lassen.