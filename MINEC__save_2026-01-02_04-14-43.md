Kernverstaendnis analysis_goal: "Minecraft Mod Studio for Kids" komplett zerlegen: alle Komponenten identifizieren, fein granular strukturieren, Datenfluesse/Vertraege visualisieren, damit wir es spaeter sauber (und sicher) wieder zusammensetzen koennen.  context_material: Repo aus minecraft-modstudio-kids-main.zip (pnpm Monorepo + Electron App + Shared Packages core-model/exporter/testbot + Fabric Template + Help Docs + Scripts/CI).  Wichtiger Befund (ehrlich): Mehrere TypeScript-Dateien enthalten sichtbare Platzhalter/Abbrueche wie ... oder abgeschnittene Strings/Zeilen. Das bedeutet:  Die Architektur und die Naehte (Interfaces) sind gut erkennbar.  Ein Teil der Implementierung ist Scaffold/Prototype und muss beim "Wiederzusammensetzen" zuerst stabilisiert werden (vor allem core-model und Teile exporter).  Kontext & Zerlegung System als 3 Schichten (1) UI/Renderer (React + Three.js) (2) Preload Bridge (sichere API: window.KidMod) (3) Electron Main (IPC, FS, Build-Pipeline, Help-Service)  Dazu kommen Packages:  @kidmodstudio/core-model: Domainmodell + Reducer + Parser + Validation + Explain  @kidmodstudio/exporter: Export in Fabric-Mod Template + Gradle Build  @kidmodstudio/testbot: Fuehrt Gradle-Run (runServer) aus + Log-Analyse  @kidmodstudio/docs-mcp: Stub  Plan-and-Solve Blueprint (PS+) Komponenteninventar (BOM): Jede Datei/Komponente mit ID, Pfad, Zweck.  Schnittstellen: Datenmodelle (Project JSON), IPC Channels, Events, Statusobjekte.  Ablaufmodelle: Sequenzen (Save/Load, Build/Test, Voice/Chat).  Wiring Plan: In welcher Reihenfolge man fehlende Teile sicher vervollstaendigt.  Risiken: Platzhalterstellen, Security Naehte, Build/Gradle Abhaengigkeiten.  Erfolgskriterien:  Vollstaendige Komponentenliste (alle 91 Dateien erfasst)  Klarer Contract fuer Project/IPC/Pipeline  Konkreter Re-Assembly Plan (Phasen, Prioritaeten, Tests)  Reasoning-Pfade (ToT, 3 Aeste) Pfad A: Dateisystem -> Modulgraph (Score 0.90) Ordnerstruktur + package.json + Imports -> klare Subsysteme und Abhaengigkeiten.  Pfad B: Runtime-Flows (Score 0.84) UI Events -> Reducer -> Persistence/IPC -> Main Services -> Rueckmeldung (Progress/Help).  Pfad C: Build-/Test-Pipeline (Score 0.92) Exporter (scaffold/generate assets) -> Gradle build -> testbot runServer -> LogAnalyzer -> UI Stepper.  Konsistenz:  A und C sind am stabilsten (Struktur/Orchestrierung klar).  B ist stabil, aber Save/Load im Main ist aktuell Stub; Renderer hat Mock-Fallback.  Tool Calls & Evidenz (Action-Log) Action-ID: run_python_calculation  Grund: ZIP entpacken, alle Dateien inventarisieren (91), package.json/tsconfig/Services/UI/Packages lesen, Import-/Abhaengigkeitsbild ableiten.  Parameter: /mnt/data/minecraft-modstudio-kids-main.zip -> Extract -> Datei-Reads (main/preload/renderer/core-model/exporter/testbot/template/scripts).  Output: Vollstaendige Komponentenliste + Architekturrekonstruktion + Schnittstellen.  A) Bill of Materials (BOM) - alle Komponenten (91) Notation: ID Pfad Zweck  R: Repo Root / CI / Workspace R01 .github/workflows/ci.yml CI Pipeline: install/lint/build/test (pnpm)  R02 .gitignore Git ignore Regeln  R03 package.json Monorepo Root Scripts (pnpm -r build/test/lint, dev, clean)  R04 pnpm-lock.yaml Lockfile (Dependency Snapshots)  R05 pnpm-workspace.yaml Workspace Definition: apps/, packages/, tools/*  R06 tsconfig.base.json Shared TS Compiler Options (NodeNext, ES2022, composite)  S: Tools / Scripts S01 tools/scripts/dev.sh Dev Start: prereq checks, pnpm install, start renderer dev  S02 tools/scripts/pack-release.sh Release dry run packaging (build packages, build app)  H: Help & UX Report H01 apps/studio-electron/resources/help/blocks.md Hilfe: Blocks  H02 apps/studio-electron/resources/help/items.md Hilfe: Items  H03 apps/studio-electron/resources/help/export.md Hilfe: Export/Testen  H04 apps/studio-electron/ui_test_report.md UI/UX Testreport (Browser Walkthrough)  K: Package/TS Configs K01 apps/studio-electron/package.json Electron App Scripts + electron-builder config  K02 apps/studio-electron/vite.config.ts Vite build fuer Renderer (base ./, alias core-model src)  K03 packages/core-model/package.json Domain Package (zod, vitest)  K04 packages/core-model/tsconfig.json TS Build config (composite)  K05 packages/core-model/tsconfig.tsbuildinfo TS Incremental Cache  K06 packages/docs-mcp/package.json Stub Package  K07 packages/docs-mcp/tsconfig.json TS Build config  K08 packages/docs-mcp/tsconfig.tsbuildinfo TS Incremental Cache  K09 packages/exporter/package.json Exporter Package  K10 packages/exporter/tsconfig.json TS Build config  K11 packages/exporter/tsconfig.tsbuildinfo TS Incremental Cache  K12 packages/testbot/package.json Testbot Package  K13 packages/testbot/tsconfig.json TS Build config  K14 packages/testbot/tsconfig.tsbuildinfo TS Incremental Cache  E: Electron Main Process E01 apps/studio-electron/src/main/index.ts App Bootstrap (BrowserWindow, wiring services)  E02 apps/studio-electron/src/main/ipc.ts IPC Handler (workspace select, save/load stubs, ops/ai stubs)  E03 apps/studio-electron/src/main/buildService.ts Build/Test Orchestrierung (export->build->test, progress events)  E04 apps/studio-electron/src/main/helpService.ts Help Loader + Search (Markdown + frontmatter)  E05 apps/studio-electron/src/main/workspace.ts Path Sandbox (assertInWorkspace, safeJoin)  E06 apps/studio-electron/src/main/tests/workspace.test.ts Tests fuer workspace policy  P: Preload Bridge P01 apps/studio-electron/src/preload/bridge.ts contextBridge: window.KidMod API + IPC  U: Renderer (React UI) U01 apps/studio-electron/src/renderer/App.tsx Root Component, Provider Composition  U02 apps/studio-electron/src/renderer/ai/commander.ts Local Command Heuristik fuer Chat  U03 apps/studio-electron/src/renderer/index.css Global Styles  U04 apps/studio-electron/src/renderer/index.html Renderer Entry HTML  U05 apps/studio-electron/src/renderer/index.tsx React Mount  U06 apps/studio-electron/src/renderer/state/ProjectContext.tsx App State + UI State + Save/Load + selection  U07 apps/studio-electron/src/renderer/state/Toast.css Toast Styles  U08 apps/studio-electron/src/renderer/state/ToastContext.tsx Toast System (addToast, auto-dismiss)  U09 apps/studio-electron/src/renderer/state/persistence.ts Bridge Wrapper + MockBridge (browser)  U10 apps/studio-electron/src/renderer/types/bridge.d.ts Typen fuer window.KidMod + PipelineStatus  U11 apps/studio-electron/src/renderer/ui/BuildDialog.tsx UI fuer Pipeline (start + progress + result)  U12 apps/studio-electron/src/renderer/ui/CreeperAvatar.tsx Avatar Component  U13 apps/studio-electron/src/renderer/ui/CreeperChat.tsx Chat UI + help fallback  U14 apps/studio-electron/src/renderer/ui/Editor.css Editor Styles  U15 apps/studio-electron/src/renderer/ui/EditorPanel.tsx Objekt-Editor (Name/ID/Texture etc.)  U16 apps/studio-electron/src/renderer/ui/Layout.css Layout Styles  U17 apps/studio-electron/src/renderer/ui/Layout.tsx Hauptlayout (Sidebar, Panels, Dialogs)  U18 apps/studio-electron/src/renderer/ui/Library.css Library Styles  U19 apps/studio-electron/src/renderer/ui/Library.tsx Library (Create/Select Blocks/Items/Recipes)  U20 apps/studio-electron/src/renderer/ui/OnboardingWizard.css Onboarding Styles  U21 apps/studio-electron/src/renderer/ui/OnboardingWizard.tsx Onboarding (Cloud/Local + Model Tier Download Simulation)  U22 apps/studio-electron/src/renderer/ui/Preview3D.tsx Three.js Preview (Block/Item preview + textures)  U23 apps/studio-electron/src/renderer/ui/StatusFooter.css Footer Styles  U24 apps/studio-electron/src/renderer/ui/StatusFooter.tsx Status/Explain + toggles  U25 apps/studio-electron/src/renderer/ui/VoiceControl.css Voice Styles  U26 apps/studio-electron/src/renderer/ui/VoiceControl.tsx Voice UI + CommandParser.parse + dispatch  U27 apps/studio-electron/src/renderer/utils/ModelManager.ts Model Tier Simulation (download state)  U28 apps/studio-electron/src/renderer/utils/TextureGenerator.ts Procedural Texture Generator (Canvas -> DataURL)  M: core-model (Domain) M01 packages/core-model/src/tests/explain.test.ts Tests: Explain output  M02 packages/core-model/src/tests/parser.test.ts Tests: Parser rules  M03 packages/core-model/src/tests/reducer.test.ts Tests: Reducer (history/undo/redo)  M04 packages/core-model/src/tests/schema.test.ts Tests: Zod Schemas  M05 packages/core-model/src/actions.ts Action Union (CREATE/UPDATE/DELETE/UNDO/REDO/LOAD)  M06 packages/core-model/src/explain.ts Kindgerechte Erklaerungen fuer letzte Action  M07 packages/core-model/src/index.ts Barrel Exports  M08 packages/core-model/src/parser.ts CommandParser (Regex, deutsch, confidence)  M09 packages/core-model/src/reducer.ts rootReducer + History/Undo/Redo (teilweise Platzhalter)  M10 packages/core-model/src/schema.ts Zod Schema (Project/Block/Item/Recipe) (teilweise Platzhalter)  M11 packages/core-model/src/validate.ts validateProject: schema + semantische Checks (teilweise Platzhalter)  X: exporter (Generator/Build) X01 packages/exporter/src/tests/exporter.test.ts Export Tests  X02 packages/exporter/src/tests/full_export.test.ts Full export Tests  X03 packages/exporter/src/tests/runner.test.ts Build runner Tests  X04 packages/exporter/src/builder.ts runBuild: Gradle wrapper detection, spawn, jar find (teilweise Platzhalter)  X05 packages/exporter/src/generators/assets.ts dataUriToBuffer (PNG DataURI -> Buffer; fallback 1x1)  X06 packages/exporter/src/generators/java.ts generateRegistryClass (Registries fuer Blocks/Items) (teilweise Platzhalter)  X07 packages/exporter/src/generators/json.ts Lang, models, blockstates, item models (teilweise Platzhalter)  X08 packages/exporter/src/index.ts exportProject: scaffold + generate + write + rename mixin + runBuild export (teilweise Platzhalter)  F: Fabric Template (vom Exporter kopiert/instanziiert) F01 packages/exporter/template/build.gradle Fabric Loom Build (teilweise Platzhalter)  F02 packages/exporter/template/gradle.properties Versionen/props  F03 packages/exporter/template/settings.gradle Gradle settings  F04 packages/exporter/template/src/main/java/com/example/TemplateMod.java ModInitializer Skeleton  F05 packages/exporter/template/src/main/resources/fabric.mod.json Fabric metadata mit Platzhaltern {{MOD_ID}}  F06 packages/exporter/template/src/main/resources/mixin.json Mixin config Vorlage  T: testbot (Gradle Run + Log Analyse) T01 packages/testbot/src/tests/testbot.test.ts Tests fuer runner/analyzer  T02 packages/testbot/src/analyzer.ts LogAnalyzer: success/crash heuristics (teilweise Platzhalter)  T03 packages/testbot/src/index.ts Barrel Exports  T04 packages/testbot/src/runner.ts runTest: spawn Gradle task, timeout, stream logs (teilweise Platzhalter)  D: docs-mcp D01 packages/docs-mcp/src/index.ts Stub Export  B) Architektur-Blueprint (Step-by-step, mit Visualisierung) B1) Prozess- und Trust-Boundaries ASCII Diagramm:  +------------------------------+ | Renderer (React + Three.js) | | - UI, State, Preview, Chat | | - ruft window.KidMod.* auf | +--------------+---------------+ | | contextBridge API v +------------------------------+ | Preload (bridge.ts) | | - ipcRenderer.invoke/on | | - exposeInMainWorld KidMod | +--------------+---------------+ | | IPC channels v +------------------------------+ | Main (Electron) | | - registerIpcHandlers | | - helpService (help:search) | | - buildService (pipeline:*) | | - workspace sandbox utils | +--------------+---------------+ | | FS / child_process / temp dirs v +------------------------------+ | Exporter + Gradle + Testbot | | - scaffold Fabric template | | - generate java/json/assets | | - gradlew build | | - gradlew runServer + parse | +------------------------------+  Trust boundary:  Renderer ist "untrusted UI".  Main darf FS/Build. Deshalb: IPC Contract muss strikt whitelisten und sanitizen (workspace.ts).  B2) Datenmodell: "Project" (Single Source of Truth) Beobachtet in UI + core-model:  Project { meta: { modId: string, name: string, version: string, description?: string, author?: string }, blocks: { [id: string]: Block }, items: { [id: string]: Item }, recipes:{ [id: string]: Recipe } }  Block (beobachtet/angenommen aus schema.ts + UI):  id: lower_snake_case (IdSchema)  name: string  type: "block"  properties: { hardness, luminance, transparent? ... } (teilweise in schema.ts, teils placeholder)  texture: { type: "procedural"|"dataUri"|..., value: "rock"|"wood"|... }  Item:  id, name, type: "item"  itemType: "gem"|"sword" (schema.ts)  properties: maxStackSize, attackDamage?  texture: analog  Recipe:  id, type: "recipe" (UI legt es so an)  pattern: string[] (3 Zeilen a 3 chars)  key: { [char: string]: itemRef }  result: { item: itemRef, count?: number }  RefSchema erlaubt namespaced IDs wie "minecraft:dirt" oder "mod:item".  Wichtig: In repo sind schema/actions/reducer an Stellen abgeschnitten (...). Obige Felder sind teils "observed", teils "intent". Beim Re-Assembly muss das finalisiert werden.  B3) State Machine: AppState + UIState AppState (core-model):  project: Project  lastAction?: KidAction|null  history: { past: Project[], future: Project[] } (Undo/Redo)  UIState (Renderer):  activeType: "block"|"item"|"recipe"|null  activeId: string|null  isSidebarOpen: boolean  voiceState: "idle"|"listening"|"processing"  transcript: string|null  Invariants:  Wenn activeType != null, dann activeId != null (sonst Editor empty state).  Undo/Redo nur fuer Project-Aenderungen, nicht fuer UIState.  B4) IPC Contract (Preload <-> Main) Invoke Channels (Renderer -> Main) dialog:selectWorkspace  project:load  project:save  ops:export (stub)  ops:build (stub)  ops:test (stub)  pipeline:start (real: buildService)  help:search (real: helpService)  ai:queryDocs (stub)  ai:suggest (stub)  Push Events (Main -> Renderer) pipeline:progress (status updates)  PipelineStatus (Renderer types):  step: "export" | "build" | "test" | "done" | "error"  message: string  progress?: number  details?: string  Security Note:  VALID_CHANNELS existiert, wird aber nicht enforced; und Save/Load sollten workspace.ts nutzen.  C) Komponentenkarten (Deep Dive: Verantwortungen, I/O, Dependencies, Tests) Ich gehe hier bewusst "tief" fuer die tragenden Teile; CSS/tsbuildinfo bleiben im BOM (oben) ausreichend beschrieben.  C1) E01 main/index.ts - App Bootstrap Zweck:  BrowserWindow konfigurieren (contextIsolation true, nodeIntegration false)  dev/prod loading (VITE_DEV_SERVER_URL vs dist renderer index.html)  Services registrieren: IPC, BuildService, HelpService  Inputs:  env: VITE_DEV_SERVER_URL  OS events: app ready/activate/window-all-closed  Outputs:  Main window lifecycle  service handlers aktiv  Risiken:  sandbox ist aktuell false (sichtbar). Spaeter ggf. haerten.  Tests:  keine direkten; indirekt via smoke run.  C2) E02 main/ipc.ts - IPC Handlers (teilweise Stub) Zweck:  dialog:selectWorkspace implementiert  project:load/save aktuell Stub  ops:* und ai:* stub  I/O:  Input: IPC invoke args (dir, json)  Output: {success,...}  Wiring-Plan:  project:save -> safeJoin + write project.json  project:load -> read project.json + validateProject + return data/errors  ops:* entweder entfernen oder auf pipeline verweisen (einheitlicher Weg)  C3) E03 main/buildService.ts - Orchestrierung (Kern) Zweck:  pipeline:start startet Export->Build->Test  sendet pipeline:progress an Renderer  Inputs:  project (Project JSON; aktuell als any)  Outputs:  status events:  export step  build step (logs/details)  test step  done/error  Dependencies:  @kidmodstudio/exporter: exportProject, runBuild  @kidmodstudio/testbot: runTest  os.tmpdir + fs/path  Failure Modes:  Exporter wirft exception  Gradle build fehlschlaegt oder jar nicht gefunden  runServer timeout/crash  Tests:  momentan in exporter/testbot; buildService selbst nicht direkt getestet.  C4) E04 main/helpService.ts - Offline Help Search Zweck:  laedt Markdown Docs mit simplem frontmatter  IPC: help:search(query) -> Ergebnisse + excerpt + fullContent  Inputs:  help markdown raw  Outputs:  array von {title, excerpt, fullContent}  Risiken:  Pfadauflosung dev vs packaged; code versucht heuristik.  Tests:  keine.  C5) E05 main/workspace.ts - Sandbox Utilities Zweck:  assertInWorkspace(root, targetPath): blockt path traversal  safeJoin(root, ...paths): kombiniert + validiert  Inputs:  workspaceRoot, relative path  Outputs:  throws error oder safe resolved path  Tests:  E06 workspace.test.ts  Wichtig:  Muss in project load/save und ggf. exporter output dir logik genutzt werden.  C6) P01 preload/bridge.ts - Window API Zweck:  exposeInMainWorld("KidMod", { ... })  wrappers fuer ipcRenderer.invoke und event subscription  Risiken:  whitelist ist definiert, aber nicht enforced  Callback signature: onBuildProgress(event, status) -> in UI als unsubscribe genutzt (gut)  Tests:  keine.  C7) U06 ProjectContext.tsx - UI State + Domain State Glue Zweck:  useReducer(rootReducer, INITIAL_STATE) aus core-model  UI selection + voice state  persistence wrapper fuer save/load + workspace selection  Inputs:  KidActions (dispatch)  persistence: saveProjectToDisk/loadProjectFromDisk/selectWorkspace  Outputs:  Context: {state, project, ui, dispatch, setSelection, save/load,...}  Failure Modes:  loadProjectFromDisk wirft error  Save ohne workspaceDir  Tests:  keine.  C8) U09 persistence.ts - Bridge Adapter + Mock Zweck:  Wenn window.KidMod nicht existiert (Browser): mockBridge  Funktionen:  saveProjectToDisk(dir, project)  loadProjectFromDisk(dir) -> Project  selectWorkspace() -> dir|null  Risiken:  Unterschiede Browser vs Electron koennen Bugs maskieren (Mock ist sehr permissiv).  C9) U17 Layout.tsx - UI Composition Zweck:  setzt Library + EditorPanel + Preview3D + Footer + Dialogs  Open/Save Buttons likely hier (und Onboarding)  Inputs:  context state, UI toggles  Outputs:  Render tree  C10) U19 Library.tsx - Create/Select Zweck:  zeigt Listen: blocks/items/recipes  "Plus" erstellt neue Objekte mit generierter ID (type_${Date.now()})  dispatch CREATE_* Actions  Inputs:  state.project.* lists  dispatch  Outputs:  neue Entities im Project state  Risiken:  IDs passen evtl. nicht zu IdSchema (Date.now() -> enthaelt nur digits/underscore, aber prefix "block_" ok; dennoch schema muss das erlauben).  verwendet as any wegen unklarer Typen (Folge der placeholder in schema/actions).  C11) U15 EditorPanel.tsx - Edit Form Zweck:  bindet Eingaben auf active object (Name, ID, Texture preset)  dispatch UPDATE_* actions  Inputs:  ui.activeType/id, state.project maps  Outputs:  Project state updates  Risiken:  ID-Aenderung ist heikel: wenn id als key in record genutzt wird, braucht man "rename" semantics (delete+insert). Falls reducer das nicht sauber macht, gehen referenzen kaputt.  C12) U22 Preview3D.tsx - 3D Visualisierung Zweck:  initialisiert Three.js scene/camera/renderer  bei Auswahl aendert es mesh + texture  nutzt TextureGenerator (procedural presets)  Inputs:  active selection + project data  Outputs:  WebGL canvas im UI  Risiken:  Recreate mesh bei jeder Aenderung; ok fuer MVP.  Textures: im Exporter fehlt aktuell die klare Kopplung (Renderer kann DataURI erzeugen, Exporter hat dataUriToBuffer - gute Naht, aber nicht komplett verdrahtet).  C13) U11 BuildDialog.tsx - Pipeline UX Zweck:  startBuildPipeline(project)  onBuildProgress subscription  Step UI export/build/test/done/error  Inputs:  window.KidMod pipeline API  Outputs:  status updates im Dialog  Risiken:  unsubscribe handling muss robust sein (bei close/unmount).  C14) U26 VoiceControl.tsx - Voice -> Parser -> Action Zweck:  voiceState idle/listening/processing  nutzt core-model CommandParser.parse(text)  dispatch action + toast bei error  Inputs:  "transcript" (aktuell simuliert, kein echtes Speech2Text)  Outputs:  KidAction dispatch oder error toast  Risiken:  Parser ist Regex/Prototype; muss stabilisiert werden.  C15) U13 CreeperChat.tsx + U02 commander.ts - Chat Heuristik + Help Fallback Zweck:  processUserCommand(): einfache pattern matching; wenn message leer -> help search  help search: window.KidMod.searchHelp(query)  Inputs:  user chat input  Outputs:  assistant message (local) oder help content  C16) M10 schema.ts - Zod Domain Schema (teilweise Placeholder) Zweck:  IdSchema: ^[a-z0-9_]+$  RefSchema: ^[a-z0-9_:]+$  BlockSchema/ItemSchema/RecipeSchema/ProjectSchema  Inputs:  raw json  Outputs:  typed objects (zod infer), defaults  Risiken:  Datei enthaelt ... (muss repariert werden)  Schema/Reducer/Actions muessen exakt zusammenpassen.  C17) M05 actions.ts - KidAction Union (teilweise Placeholder) Zweck:  UPDATE_META, CREATE/UPDATE/DELETE fuer block/item/recipe  UNDO/REDO, LOAD_PROJECT  Risiko:  LOAD_PROJECT payload ist abgeschnitten (any...). Muss definiert werden: ideal Project oder ProjectFile.  C18) M09 reducer.ts - rootReducer + History (teilweise Placeholder) Zweck:  project reducer: actions -> new project  wrapper: history past/future, undo/redo limit  Risiken:  Datei ist an mehreren Stellen abgeschnitten; dennoch ist rootReducer sichtbar.  ID rename semantics falls Editor ID edit erlaubt.  Tests:  M03 reducer.test.ts (sollte Kernfaelle abdecken, wenn file repariert ist).  C19) M08 parser.ts - CommandParser (teilweise Placeholder) Zweck:  parse(text) -> {action|null, confidence, error?}  Regex deutsch; z.B. "erstelle block ..."  Risiken:  Parser test (M02) deutet intendierte patterns an.  C20) M11 validate.ts - validateProject + Semantik Zweck:  ProjectSchema.safeParse  semantische checks: recipe key references existierende items oder minecraft:*  Outputs:  {success:true,data} oder {success:false,errors[]}  C21) X08 exporter/index.ts - exportProject (teilweise Placeholder) Zweck (intent):  scaffold template -> outputDir  ersetze Platzhalter (MOD_ID, name, description)  generiere code/assets:  java registry class  lang json  blockstates/models  textures (via dataUriToBuffer)  rename mixin.json -> {modId}.mixins.json  optional: expose runBuild  Risiken:  Datei ist stark abgeschnitten; muss als erstes im exporter stabilisiert werden.  C22) X04 builder.ts - runBuild (teilweise Placeholder) Zweck:  finde gradlew (win/unix), chmod, spawn build  sammle logs  suche jar artifact (z.B. build/libs/*.jar)  Failure Modes:  gradle wrapper fehlt  java fehlt  build exit code != 0  jar not found  C23) X06 java.ts - generateRegistryClass (teilweise Placeholder) Zweck:  erzeugt Java code fuer Registry.register Blocks/Items  optional item groups  Risiko:  string interpolation ist abgeschnitten (${s...)  C24) X07 json.ts - models/blockstates/lang Zweck:  generateLangJson: block.modid.id -> name etc.  blockstate/model jsons  item model jsons  C25) F* Fabric Template Zweck:  Basisprojekt fuer Fabric Loom; exporter kopiert und ersetzt:  com.example -> eigenes package  TemplateMod -> eigenes Mod class naming  fabric.mod.json id/version/name  mixin config  C26) T04 runner.ts - runTest (teilweise Placeholder) Zweck:  spawn gradle task runServer (default)  timeout 3 min  stream logs -> analyzer  Outputs:  {success, logs, error?}  C27) T02 analyzer.ts - LogAnalyzer (teilweise Placeholder) Zweck:  heuristics fuer success/crash:  success: typische minecraft server "Done"  crash: exception lines, incompatible mod set, mixin apply failed  D) Sequenzdiagramme (kritische Flows) D1) Build/Test Pipeline (Button -> Ergebnis) Renderer (BuildDialog)  subscribe: onBuildProgress(cb)  invoke: pipeline:start(project)  Main (buildService) 3) create tmpDir 4) send progress: {step:"export",...} 5) exporter.exportProject(tmpDir, project) 6) send progress: {step:"build",...} 7) exporter.runBuild(tmpDir) 8) send progress: {step:"test",...} 9) testbot.runTest(tmpDir,"runServer") 10) send progress: - done oder error(details)  Renderer 11) update UI stepper 12) unsubscribe on close/unmount  D2) Save/Load (gewuenscht, aber Main aktuell Stub) Soll-Flow: Renderer -> window.KidMod.saveProject(dir, projectJson) Main -> safeJoin(dir,"project.json") -> write -> return {success} Renderer -> toast "saved"  Load: Renderer -> loadProject(dir) Main -> read project.json -> validateProject -> return data/errors Renderer -> dispatch LOAD_PROJECT(project)  D3) Voice Command mouseDown -> ui.voiceState="listening"  mouseUp -> ui.voiceState="processing" + transcript set  CommandParser.parse(transcript)  wenn action != null: dispatch(action) + optional selection  sonst: toast error + idle  D4) Chat Command input -> commander.processUserCommand  wenn message != "": zeige message, optional dispatch(action)  wenn message == "": call help:search(query) -> zeige excerpt/fullContent  E) Wiring Plan (wie wir es "klug und intelligent" wieder zusammensetzen) Phase 1: "Domain Truth" stabilisieren (core-model first) M10 schema.ts vollstaendig machen (alle ... entfernen)  M05 actions.ts: LOAD_PROJECT sauber typisieren (am besten Project)  M09 reducer.ts reparieren:  projectReducer fuer alle actions  rootReducer history wrapper (undo/redo)  ID rename semantics entscheiden:  Option A: ID ist immutable (UI darf id nicht editieren)  Option B: eigene Action RENAME_* implementieren (safe move in record + update recipe refs)  M11 validate.ts vervollstaendigen + Tests M01-M04 gruener Zustand  Phase 2: Persistence/IPC Contract schliessen E02 ipc.ts: project:save/load implementieren  E05 workspace.ts erzwingen (keine path traversal)  P01 bridge.ts: whitelist enforcement (optional) + typing strikter  Phase 3: Exporter end-to-end X08 exportProject reparieren und deterministische Output-Struktur festlegen  textures:  Renderer TextureGenerator -> DataURI  Exporter dataUriToBuffer -> PNG file in assets/modid/textures  Java/JSON generatoren ohne placeholders (X06/X07)  Phase 4: Build/Test Robustheit builder.ts: wrapper detection + jar find robust  testbot runner/analyzer: eindeutige success/crash detection, bessere crash reasons  buildService: error messages kindgerecht (und actionable)  Phase 5: UX polish UI_test_report items umsetzen (toasts existieren bereits, save/load feedback etc.)  Reflexion & Bias-Report Faktisch vs inferiert:  Faktisch: Datei-/Ordnerstruktur, sichtbare APIs, vorhandene Services und IPC channels.  Inferiert (markiert): einige Details zu finalem Project Schema und Export Output, weil schema/exporter Dateien an Stellen abgeschnitten sind.  Risiko:  Hauptunsicherheit liegt in den ...-Platzhalterstellen. Ich habe diese nicht "ausphantasiert", sondern als Arbeitspunkte fuer Phase 1/3 markiert.